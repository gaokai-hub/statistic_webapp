<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç»Ÿè®¡åˆ†å¸ƒæ¨¡æ‹Ÿåˆ†æå·¥å…·</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="dashscope_integration.js"></script>
    <style>
        :root {
            --primary-color: #4a6fa5;
            --secondary-color: #6b8cb7;
            --accent-color: #f9a03f;
            --success-color: #4caf50;
            --warning-color: #ff9800;
            --danger-color: #f44336;
            --background-color: #f5f7fa;
            --card-background: #ffffff;
            --text-primary: #333333;
            --text-secondary: #666666;
            --border-color: #e0e0e0;
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--background-color);
            color: var(--text-primary);
            line-height: 1.6;
        }
        
        header {
            background-color: var(--primary-color);
            color: white;
            padding: 20px 0;
            text-align: center;
            box-shadow: var(--shadow);
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        /* ç»Ÿè®¡å¡ç‰‡ç½‘æ ¼å¸ƒå±€ */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .stats-container {
            margin-top: 20px;
            padding: 15px;
            background-color: var(--card-background);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow);
        }
        
        .stats-container h3 {
            margin-top: 0;
            color: var(--text-primary);
            font-size: 18px;
            margin-bottom: 15px;
        }
        
        .tabs {
            display: flex;
            margin-bottom: 20px;
            background-color: white;
            border-radius: 8px 8px 0 0;
            box-shadow: var(--shadow);
            overflow: hidden;
        }
        
        .tab {
            padding: 15px 25px;
            cursor: pointer;
            border: none;
            background-color: transparent;
            font-size: 16px;
            font-weight: 500;
            color: var(--text-secondary);
            transition: all 0.3s ease;
            position: relative;
        }
        
        .tab:hover {
            background-color: rgba(74, 111, 165, 0.05);
        }
        
        .tab.active {
            color: var(--primary-color);
            font-weight: 600;
        }
        
        .tab.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background-color: var(--primary-color);
        }
        
        .tab-content {
            background-color: white;
            border-radius: 0 0 8px 8px;
            box-shadow: var(--shadow);
            padding: 20px;
            min-height: 500px;
        }
        
        .tab-content.hidden {
            display: none;
        }
        
        h2 {
            color: var(--primary-color);
            margin-bottom: 20px;
            font-size: 24px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-row {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .form-row .form-group {
            flex: 1;
            margin-bottom: 0;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: var(--text-primary);
        }
        
        input[type="number"],
        select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }
        
        input[type="number"]:focus,
        select:focus {
            outline: none;
            border-color: var(--primary-color);
        }
        
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        
        button:hover {
            background-color: var(--secondary-color);
        }
        
        button.secondary {
            background-color: transparent;
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }
        
        button.secondary:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }
        
        .button-group {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }
        
        .chart-container {
            position: relative;
            height: 400px;
            margin-top: 30px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .stat-card {
            background-color: var(--background-color);
            padding: 15px;
            border-radius: 6px;
            border-left: 3px solid var(--primary-color);
        }
        
        .stat-label {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 20px;
            font-weight: 600;
            color: var(--primary-color);
        }
        
        .hidden {
            display: none;
        }
        
        /* å‡è®¾æ£€éªŒç»“æœé«˜äº®æ ·å¼ */
        .highlight-reject {
            background-color: #ffebee;
            border-left-color: #f44336;
            border-left-width: 5px;
        }
        
        .highlight-accept {
            background-color: #e8f5e9;
            border-left-color: #4caf50;
            border-left-width: 5px;
        }
        
        .progress-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 5px;
            background-color: rgba(255, 255, 255, 0.3);
            z-index: 9999;
        }
        
        .progress-fill {
            height: 100%;
            background-color: var(--success-color);
            transition: width 0.3s ease;
        }
        
        .progress-text {
            position: absolute;
            top: 10px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .help-text {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 5px;
        }
        
        .card {
            background-color: white;
            border-radius: 8px;
            box-shadow: var(--shadow);
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            margin-right: 5px;
        }
        
        .badge-primary {
            background-color: var(--primary-color);
            color: white;
        }
        
        .badge-success {
            background-color: var(--success-color);
            color: white;
        }
        
        .badge-warning {
            background-color: var(--warning-color);
            color: white;
        }
        
        .highlight {
            background-color: #fff9c4;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>ç»Ÿè®¡åˆ†å¸ƒæ¨¡æ‹Ÿåˆ†æå·¥å…·</h1>
            <p class="subtitle">é€šè¿‡æ¨¡æ‹Ÿä¸åŒæ¦‚ç‡åˆ†å¸ƒï¼Œè¿›è¡Œæ•°æ®åˆ†æä¸å¯è§†åŒ–</p>
        </div>
    </header>
    
    <div class="container">
        <div class="tabs">
            <button class="tab active" data-tab="distribution">æ¦‚ç‡åˆ†å¸ƒæ¨¡æ‹Ÿ</button>
            <button class="tab" data-tab="confidence">ç½®ä¿¡åŒºé—´åˆ†æ</button>
            <button class="tab" data-tab="analysis">æ•°æ®åˆ†æ</button>
            <button class="tab" data-tab="hypothesis">å‡è®¾æ£€éªŒ</button>
        </div>
        
        <div id="hypothesis" class="tab-content hidden">
            <h2>å‡è®¾æ£€éªŒ</h2>
            
            <div class="card">
                <h3>æ£€éªŒè®¾ç½®</h3>
                
                <div class="form-group">
                    <label for="test-type">æ£€éªŒç±»å‹</label>
                    <select id="test-type">
                        <option value="z-test">å•æ ·æœ¬Zæ£€éªŒ</option>
                        <option value="t-test">å•æ ·æœ¬Tæ£€éªŒ</option>
                        <option value="two-sample-t">åŒæ ·æœ¬Tæ£€éªŒ</option>
                        <option value="anova">å•å› ç´ æ–¹å·®åˆ†æ</option>
                    </select>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="significance-level">æ˜¾è‘—æ€§æ°´å¹³ (Î±)</label>
                        <select id="significance-level">
                            <option value="0.01">0.01</option>
                            <option value="0.05" selected>0.05</option>
                            <option value="0.10">0.10</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="test-direction">æ£€éªŒæ–¹å‘</label>
                        <select id="test-direction">
                            <option value="two-tailed" selected>åŒä¾§æ£€éªŒ</option>
                            <option value="left-tailed">å·¦ä¾§æ£€éªŒ</option>
                            <option value="right-tailed">å³ä¾§æ£€éªŒ</option>
                        </select>
                    </div>
                </div>
                
                <div id="one-sample-params">
                    <h4>å•æ ·æœ¬æ£€éªŒå‚æ•°</h4>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="population-mean">å‡è®¾æ€»ä½“å‡å€¼ (Î¼â‚€)</label>
                            <input type="number" id="population-mean" value="0" step="0.1" required>
                        </div>
                        <div class="form-group">
                            <label for="population-std">æ€»ä½“æ ‡å‡†å·® (Ïƒ) <span class="help-text">(Zæ£€éªŒéœ€è¦)</span></label>
                            <input type="number" id="population-std" value="1" step="0.1" min="0.01">
                        </div>
                    </div>
                </div>
                
                <div id="two-sample-params" class="hidden">
                    <h4>åŒæ ·æœ¬æ£€éªŒå‚æ•°</h4>
                    <div class="form-group">
                        <label for="sample-method">æ ·æœ¬é€‰æ‹©æ–¹å¼</label>
                        <select id="sample-method">
                            <option value="use-generated">ä½¿ç”¨å·²ç”Ÿæˆçš„æ•°æ®</option>
                            <option value="manual-entry">æ‰‹åŠ¨è¾“å…¥</option>
                        </select>
                    </div>
                    <div id="manual-sample-input" class="hidden">
                        <div class="form-group">
                            <label for="sample1-data">æ ·æœ¬1æ•°æ® (é€—å·åˆ†éš”)</label>
                            <textarea id="sample1-data" rows="4" placeholder="ä¾‹å¦‚: 1,2,3,4,5"></textarea>
                        </div>
                        <div class="form-group">
                            <label for="sample2-data">æ ·æœ¬2æ•°æ® (é€—å·åˆ†éš”)</label>
                            <textarea id="sample2-data" rows="4" placeholder="ä¾‹å¦‚: 2,3,4,5,6"></textarea>
                        </div>
                    </div>
                </div>
                
                <div id="anova-params" class="hidden">
                    <h4>æ–¹å·®åˆ†æå‚æ•°</h4>
                    <div class="form-group">
                        <p>æ–¹å·®åˆ†æéœ€è¦è‡³å°‘ä¸¤ç»„æ•°æ®ï¼Œè¯·ä½¿ç”¨æ‰‹åŠ¨è¾“å…¥æ–¹å¼ã€‚</p>
                    </div>
                </div>
                
                <div class="button-group">
                    <button id="calculate-test" class="btn btn-primary">è®¡ç®—å‡è®¾æ£€éªŒ</button>
                    <button id="clear-test-results" class="btn btn-secondary">æ¸…é™¤ç»“æœ</button>
                </div>
            </div>
            
            <!-- åŠŸæ•ˆå‡½æ•°è®¡ç®—éƒ¨åˆ† -->
            <div class="card">
                <h3>åŠŸæ•ˆå‡½æ•°è®¡ç®—</h3>
                
                <div class="form-group">
                    <label for="power-analysis-type">æ£€éªŒç±»å‹</label>
                    <select id="power-analysis-type">
                        <option value="one-sample-mean">å•æ ·æœ¬å‡å€¼æ£€éªŒ</option>
                        <option value="two-sample-mean">åŒæ ·æœ¬å‡å€¼æ£€éªŒ</option>
                        <option value="proportion">æ¯”ä¾‹æ£€éªŒ</option>
                    </select>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="alpha-value">æ˜¾è‘—æ€§æ°´å¹³ (Î±)</label>
                        <input type="number" id="alpha-value" value="0.05" step="0.01" min="0.001" max="0.5">
                    </div>
                    <div class="form-group">
                        <label for="power-value">åŠŸæ•ˆ (1-Î²)</label>
                        <input type="number" id="power-value" value="0.8" step="0.01" min="0.5" max="0.99">
                    </div>
                </div>
                
                <div class="form-group">
                    <label for="effect-size">æ•ˆåº”å¤§å° (Î”)</label>
                    <input type="number" id="effect-size" value="0.5" step="0.01" min="0.01">
                    <span class="help-text">ä¾‹å¦‚: Î¼â‚-Î¼â‚€ æˆ– pâ‚-pâ‚€</span>
                </div>
                
                <div id="std-input" class="form-group">
                    <label for="std-deviation">æ ‡å‡†å·® (Ïƒ)</label>
                    <input type="number" id="std-deviation" value="1" step="0.1" min="0.01">
                    <span class="help-text">ä»…ç”¨äºå‡å€¼æ£€éªŒ</span>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="power-test-direction">æ£€éªŒæ–¹å‘</label>
                        <select id="power-test-direction">
                            <option value="two-tailed">åŒä¾§æ£€éªŒ</option>
                            <option value="one-tailed">å•ä¾§æ£€éªŒ</option>
                        </select>
                    </div>
                </div>
                
                <div id="proportion-params" class="form-row hidden">
                    <div class="form-group">
                        <label for="proportion-p0">æ¯”ä¾‹ pâ‚€</label>
                        <input type="number" id="proportion-p0" value="0.5" step="0.01" min="0.01" max="0.99">
                    </div>
                    <div class="form-group">
                        <label for="proportion-p1">æ¯”ä¾‹ pâ‚</label>
                        <input type="number" id="proportion-p1" value="0.6" step="0.01" min="0.01" max="0.99">
                    </div>
                </div>
                
                <div class="form-group">
                    <label><input type="checkbox" id="show-formula"> æ˜¾ç¤ºè®¡ç®—å…¬å¼</label>
                    <label style="margin-left: 20px;"><input type="checkbox" id="show-power-chart"> æ˜¾ç¤ºåŠŸæ•ˆå‡½æ•°å›¾è¡¨</label>
                </div>
                
                <div class="button-group">
                    <button id="calculate-power" class="btn btn-primary">è®¡ç®—æ ·æœ¬é‡</button>
                    <button id="clear-power-results" class="btn btn-secondary">æ¸…é™¤ç»“æœ</button>
                </div>
            </div>
            
            <!-- åŠŸæ•ˆå‡½æ•°è®¡ç®—ç»“æœåŒºåŸŸ -->
            <div id="power-results" class="hidden">
                <h3>æ ·æœ¬é‡è®¡ç®—ç»“æœ</h3>
                <div class="stats-container">
                    <div id="power-summary" class="stats-grid"></div>
                </div>
                
                <div id="formula-container" class="hidden">
                    <h4>è®¡ç®—å…¬å¼</h4>
                    <div id="power-formula" class="formula-display"></div>
                </div>
                
                <div id="power-chart-container" class="chart-container hidden">
                    <canvas id="power-chart"></canvas>
                </div>
            </div>
            
            <div id="test-results" class="hidden">
                <h3>æ£€éªŒç»“æœ</h3>
                <div class="stats-container">
                    <div id="test-summary" class="stats-grid"></div>
                </div>
                
                <div id="test-chart-container" class="chart-container hidden">
                    <canvas id="test-chart"></canvas>
                </div>
            </div>
        </div>
        
        <div id="distribution" class="tab-content">
            <h2>æ¦‚ç‡åˆ†å¸ƒæ¨¡æ‹Ÿ</h2>
            
            <div class="form-group">
                <label for="distribution-type">åˆ†å¸ƒç±»å‹</label>
                <select id="distribution-type">
                    <option value="normal">æ­£æ€åˆ†å¸ƒ</option>
                    <option value="binomial">äºŒé¡¹åˆ†å¸ƒ</option>
                    <option value="poisson">æ³Šæ¾åˆ†å¸ƒ</option>
                    <option value="uniform">å‡åŒ€åˆ†å¸ƒ</option>
                    <option value="exponential">æŒ‡æ•°åˆ†å¸ƒ</option>
                </select>
            </div>
            
            <!-- æ­£æ€åˆ†å¸ƒå‚æ•° -->
            <div id="normal-params" class="param-group">
                <div class="form-row">
                    <div class="form-group">
                        <label for="normal-mean">å‡å€¼ (Î¼)</label>
                        <input type="number" id="normal-mean" value="0" step="0.1" required>
                    </div>
                    <div class="form-group">
                        <label for="normal-std">æ ‡å‡†å·® (Ïƒ)</label>
                        <input type="number" id="normal-std" value="1" step="0.1" min="0.1" required>
                    </div>
                </div>
            </div>
            
            <!-- äºŒé¡¹åˆ†å¸ƒå‚æ•° -->
            <div id="binomial-params" class="param-group hidden">
                <div class="form-row">
                    <div class="form-group">
                        <label for="binomial-n">è¯•éªŒæ¬¡æ•° (n)</label>
                        <input type="number" id="binomial-n" value="10" step="1" min="1" required>
                    </div>
                    <div class="form-group">
                        <label for="binomial-p">æˆåŠŸæ¦‚ç‡ (p)</label>
                        <input type="number" id="binomial-p" value="0.5" step="0.01" min="0" max="1" required>
                    </div>
                </div>
            </div>
            
            <!-- æ³Šæ¾åˆ†å¸ƒå‚æ•° -->
            <div id="poisson-params" class="param-group hidden">
                <div class="form-row">
                    <div class="form-group">
                        <label for="poisson-lambda">é€Ÿç‡å‚æ•° (Î»)</label>
                        <input type="number" id="poisson-lambda" value="5" step="0.1" min="0.01" required>
                    </div>
                </div>
            </div>
            
            <!-- å‡åŒ€åˆ†å¸ƒå‚æ•° -->
            <div id="uniform-params" class="param-group hidden">
                <div class="form-row">
                    <div class="form-group">
                        <label for="uniform-min">æœ€å°å€¼ (a)</label>
                        <input type="number" id="uniform-min" value="0" step="0.1" required>
                    </div>
                    <div class="form-group">
                        <label for="uniform-max">æœ€å¤§å€¼ (b)</label>
                        <input type="number" id="uniform-max" value="1" step="0.1" required>
                    </div>
                </div>
            </div>
            
            <!-- æŒ‡æ•°åˆ†å¸ƒå‚æ•° -->
            <div id="exponential-params" class="param-group hidden">
                <div class="form-row">
                    <div class="form-group">
                        <label for="exponential-lambda">é€Ÿç‡å‚æ•° (Î»)</label>
                        <input type="number" id="exponential-lambda" value="1" step="0.1" min="0.01" required>
                    </div>
                </div>
            </div>
            
            <div class="form-group">
                <label for="sample-size">æ ·æœ¬å¤§å°</label>
                <input type="number" id="sample-size" value="1000" step="100" min="100" max="10000" required>
            </div>
            
            <div class="button-group">
                <button id="generate-data">ç”Ÿæˆæ•°æ®</button>
                <button id="clear-data" class="secondary">æ¸…é™¤æ•°æ®</button>
            </div>
            
            <div id="distribution-chart-container" class="chart-container hidden">
                <canvas id="distribution-chart"></canvas>
            </div>
            
            <div id="distribution-stats" class="stats-grid hidden"></div>
        </div>
        
        <div id="confidence" class="tab-content hidden">
            <h2>ç½®ä¿¡åŒºé—´åˆ†æ</h2>
            
            <div class="card">
                <h3>åˆ†æè®¾ç½®</h3>
                
                <div class="form-group">
                    <label>æ•°æ®è¾“å…¥æ–¹å¼</label>
                    <div>
                        <label><input type="radio" name="confidence-data-method" value="sample" checked> ä½¿ç”¨æ ·æœ¬æ•°æ®</label>
                        <label><input type="radio" name="confidence-data-method" value="population" style="margin-left: 20px;"> ä½¿ç”¨æ€»ä½“å‚æ•°</label>
                        <label><input type="radio" name="confidence-data-method" value="generate" style="margin-left: 20px;"> ç”Ÿæˆéšæœºæ ·æœ¬</label>
                    </div>
                </div>
                
                <div id="sample-data-section">
                    <div class="form-group">
                        <label for="sample-data">æ ·æœ¬æ•°æ® (é€—å·åˆ†éš”)</label>
                        <textarea id="sample-data" rows="4" placeholder="ä¾‹å¦‚: 1,2,3,4,5,6,7,8,9,10"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="confidence-test-type">æ£€éªŒæ–¹æ³•</label>
                        <select id="confidence-test-type">
                            <option value="z-test">Zæ£€éªŒ (å·²çŸ¥æ€»ä½“æ ‡å‡†å·®)</option>
                            <option value="t-test" selected>Tæ£€éªŒ (æœªçŸ¥æ€»ä½“æ ‡å‡†å·®)</option>
                        </select>
                    </div>
                    <div id="sample-std-section" class="form-group hidden">
                        <label for="sample-population-std">æ€»ä½“æ ‡å‡†å·® (Ïƒ)</label>
                        <input type="number" id="sample-population-std" value="1" step="0.1" min="0.1">
                    </div>
                </div>
                
                <div id="population-data-section" class="hidden">
                    <div class="form-group">
                        <label for="confidence-level">ç½®ä¿¡æ°´å¹³</label>
                        <select id="confidence-level">
                            <option value="0.90">90%</option>
                            <option value="0.95" selected>95%</option>
                            <option value="0.99">99%</option>
                            <option value="0.999">99.9%</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label for="population-mean">æ ·æœ¬å‡å€¼ (xÌ„)</label>
                        <input type="number" id="population-mean" value="0" step="0.1" required>
                    </div>
                    
                    <div class="form-group">
                        <label for="population-std">æ ‡å‡†å·®</label>
                        <select id="std-type">
                            <option value="population">æ€»ä½“æ ‡å‡†å·® (Ïƒ)</option>
                            <option value="sample">æ ·æœ¬æ ‡å‡†å·® (s)</option>
                        </select>
                        <input type="number" id="population-std" value="1" step="0.1" min="0.1" required>
                    </div>
                    
                    <div class="form-group">
                        <label for="sample-size-confidence">æ ·æœ¬å¤§å°</label>
                        <input type="number" id="sample-size-confidence" value="30" step="1" min="1" required>
                    </div>
                </div>
                
                <div id="generate-data-section" class="hidden">
                    <div class="form-row">
                        <div class="form-group">
                            <label for="generate-distribution">åˆ†å¸ƒç±»å‹</label>
                            <select id="generate-distribution">
                                <option value="normal">æ­£æ€åˆ†å¸ƒ</option>
                                <option value="uniform">å‡åŒ€åˆ†å¸ƒ</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="generate-mean">å‡å€¼</label>
                            <input type="number" id="generate-mean" value="0" step="0.1">
                        </div>
                        <div class="form-group">
                            <label for="generate-std">æ ‡å‡†å·®</label>
                            <input type="number" id="generate-std" value="1" step="0.1" min="0.1">
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="generate-sample-size">æ ·æœ¬å¤§å°</label>
                            <input type="number" id="generate-sample-size" value="30" step="1" min="1">
                        </div>
                        <div class="form-group">
                            <label for="generate-confidence-level">ç½®ä¿¡æ°´å¹³</label>
                            <select id="generate-confidence-level">
                                <option value="0.90">90%</option>
                                <option value="0.95" selected>95%</option>
                                <option value="0.99">99%</option>
                            </select>
                        </div>
                    </div>
                    <button id="generate-confidence-sample" class="secondary">ç”Ÿæˆæ ·æœ¬å¹¶åˆ†æ</button>
                </div>
                
                <div class="button-group">
                    <button id="calculate-confidence">è®¡ç®—ç½®ä¿¡åŒºé—´</button>
                    <button id="calculate-sample-size" class="secondary">è®¡ç®—æ‰€éœ€æ ·æœ¬é‡</button>
                    <button id="clear-confidence-results" class="secondary">æ¸…é™¤ç»“æœ</button>
                </div>
            </div>
            
            <div id="sample-size-calculator" class="card hidden">
                <h3>æ ·æœ¬é‡è®¡ç®—</h3>
                <div class="form-row">
                    <div class="form-group">
                        <label for="margin-error">æœŸæœ›è¾¹é™…è¯¯å·®</label>
                        <input type="number" id="margin-error" value="0.5" step="0.01" min="0.01">
                    </div>
                    <div class="form-group">
                        <label for="ss-confidence-level">ç½®ä¿¡æ°´å¹³</label>
                        <select id="ss-confidence-level">
                            <option value="0.90">90%</option>
                            <option value="0.95" selected>95%</option>
                            <option value="0.99">99%</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="ss-population-std">æ€»ä½“æ ‡å‡†å·® (Ïƒ)</label>
                        <input type="number" id="ss-population-std" value="1" step="0.1" min="0.01">
                    </div>
                </div>
                <button id="compute-sample-size" class="secondary">è®¡ç®—æ ·æœ¬é‡</button>
                <div id="sample-size-result" class="stats-container hidden"></div>
            </div>
            
            <div id="confidence-results" class="hidden">
                <h3>åˆ†æç»“æœ</h3>
                <div class="stats-container">
                    <div id="confidence-summary" class="stats-grid"></div>
                </div>
                
                <div id="confidence-chart-container" class="chart-container">
                    <canvas id="confidence-chart"></canvas>
                </div>
                
                <div id="confidence-interpretation" class="card hidden">
                    <h3>ç»“æœè§£é‡Š</h3>
                    <div id="interpretation-text"></div>
                </div>
            </div>
        </div>
        
        <div id="analysis" class="tab-content hidden">
            <h2>æ•°æ®åˆ†æ</h2>
            
            <div class="form-group">
                <label>æ•°æ®è¾“å…¥æ–¹å¼</label>
                <div>
                    <label><input type="radio" name="data-input-method" id="data-input-method" value="distribution" checked> ä½¿ç”¨åˆ†å¸ƒç”Ÿæˆæ•°æ®</label>
                    <label><input type="radio" name="data-input-method" id="data-input-method" value="file" style="margin-left: 20px;"> ä¸Šä¼ CSVæ–‡ä»¶</label>
                    <label><input type="radio" name="data-input-method" id="data-input-method" value="ai" style="margin-left: 20px;"> AIç”Ÿæˆæ•°æ®</label>
                </div>
            </div>
            
            <div id="file-data-input" class="form-group hidden">
                <label for="file-upload">ä¸Šä¼ CSVæ–‡ä»¶</label>
                <input type="file" id="file-upload" accept=".csv">
                <p class="help-text" style="font-size: 12px; color: var(--text-secondary); margin-top: 5px;">æ”¯æŒCSVæ ¼å¼ï¼Œæ¯è¡Œä¸€ä¸ªæ•°æ®æˆ–é€—å·åˆ†éš”çš„æ•°æ®ã€‚</p>
            </div>
            
            <div id="ai-data-input" class="form-group hidden">
                <label for="ai-data-description">æ•°æ®æè¿°</label>
                <textarea id="ai-data-description" rows="3" placeholder="è¯·æè¿°æ‚¨æƒ³è¦çš„æ•°æ®ç‰¹å¾ï¼Œä¾‹å¦‚ï¼šç”Ÿæˆ1000ä¸ªæ¨¡æ‹Ÿè‚¡ç¥¨ä»·æ ¼æ•°æ®ï¼Œå‘ˆç°ä¸€å®šçš„è¶‹åŠ¿å’Œæ³¢åŠ¨æ€§"></textarea>
                <div class="form-row">
                    <div class="form-group" style="flex: 1; margin-right: 10px;">
                        <label for="ai-data-count">æ•°æ®ç‚¹æ•°é‡</label>
                        <input type="number" id="ai-data-count" min="100" max="10000" value="1000">
                    </div>
                    <div class="form-group" style="flex: 1;">
                        <label for="ai-data-seed">éšæœºç§å­ï¼ˆå¯é€‰ï¼‰</label>
                        <input type="number" id="ai-data-seed" min="0" max="999999">
                    </div>
                </div>
                <button id="generate-ai-data" class="btn btn-primary">ç”ŸæˆAIæ•°æ®</button>
                <p class="help-text" style="font-size: 12px; color: var(--text-secondary); margin-top: 5px;">åŸºäºæ‚¨çš„æè¿°ï¼Œç³»ç»Ÿå°†ç”Ÿæˆç¬¦åˆç‰¹å¾çš„æ¨¡æ‹Ÿæ•°æ®ã€‚</p>
            </div>
            
            <div class="form-group">
                    <label for="chart-type">å›¾è¡¨ç±»å‹</label>
                    <select id="chart-type">
                        <option value="histogram">ç›´æ–¹å›¾</option>
                        <option value="bar">æ¡å½¢å›¾</option>
                        <option value="scatter">æ•£ç‚¹å›¾</option>
                        <option value="line">æŠ˜çº¿å›¾</option>
                    </select>
                </div>
            
            <div class="button-group">
                <button id="analyze-data">åˆ†ææ•°æ®</button>
                <button id="reset-analysis" class="secondary">é‡ç½®åˆ†æ</button>
            </div>
            
            <!-- å‚æ•°ä¼°è®¡æ–¹æ³•é€‰æ‹© -->
            <div id="parameter-estimation" class="form-group">
                <h3>å‚æ•°ä¼°è®¡</h3>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label for="estimation-method">ä¼°è®¡æ–¹æ³•:</label>
                    <select id="estimation-method">
                        <option value="mom">çŸ©ä¼°è®¡æ³•(MOM)</option>
                        <option value="mle">æœ€å¤§ä¼¼ç„¶ä¼°è®¡æ³•(MLE)</option>
                    </select>
                    <button id="reestimate-btn" class="btn btn-secondary">é‡æ–°ä¼°è®¡å‚æ•°</button>
                </div>
            </div>
            
            <!-- å‚æ•°ä¼°è®¡ç»“æœ -->
            <div id="parameter-estimation-results" class="stats-container hidden">
                <h3>å‚æ•°ä¼°è®¡ç»“æœ</h3>
                <div id="estimation-results-grid" class="stats-grid"></div>
            </div>
            
            <div id="analysis-chart-container" class="chart-container hidden">
                <canvas id="analysis-chart"></canvas>
            </div>
        </div>
    </div>
    
    <!-- è¿›åº¦æ¡ -->
    <div id="generation-progress" class="progress-container hidden">
        <div class="progress-fill"></div>
        <div class="progress-text">æ­£åœ¨ç”Ÿæˆæ•°æ®...</div>
    </div>
    
    <script>
        // ç»Ÿè®¡åº”ç”¨ç¨‹åºå¯¹è±¡
        const StatApp = {
            // åº”ç”¨ç¨‹åºçŠ¶æ€
            currentChart: null,
            generatedData: null,
            ai: null,
            
            // åˆå§‹åŒ–åº”ç”¨ç¨‹åº
            init() {
                console.log('åˆå§‹åŒ–åº”ç”¨ç¨‹åº...');
                try {
                    this.setupEventListeners();
                    this.setupTabs();
                    this.setupDistributionTypeChange();
                    this.setupChartTypeChangeListener();
                    // åˆå§‹åŒ–AIé›†æˆ
                    this.initAIIntegration();
                    // è®¾ç½®å‚æ•°ä¼°è®¡æŒ‰é’®ç‚¹å‡»äº‹ä»¶
                    this.setupParameterEstimationButton();
                    // åˆå§‹åŒ–å‡è®¾æ£€éªŒåŠŸèƒ½
                    this.initHypothesisTesting();
                    // åˆå§‹åŒ–ç½®ä¿¡åŒºé—´åˆ†æåŠŸèƒ½
                    this.initConfidenceIntervalEvents();
                    // åˆå§‹åŒ–åŠŸæ•ˆå‡½æ•°è®¡ç®—åŠŸèƒ½
                    this.initPowerAnalysis();
                    console.log('åº”ç”¨ç¨‹åºåˆå§‹åŒ–å®Œæˆ');
                } catch (error) {
                    console.error('åˆå§‹åŒ–åº”ç”¨æ—¶å‡ºé”™:', error);
                    alert('åº”ç”¨ç¨‹åºåˆå§‹åŒ–å¤±è´¥: ' + error.message);
                }
            },
            
            // è®¾ç½®å‚æ•°ä¼°è®¡æŒ‰é’®ç‚¹å‡»äº‹ä»¶
            setupParameterEstimationButton() {
                const reestimateBtn = document.getElementById('reestimate-btn');
                if (reestimateBtn) {
                    reestimateBtn.addEventListener('click', () => {
                        this.estimateParameters();
                    });
                }
            },
            
            // å‚æ•°ä¼°è®¡æ–¹æ³•
            estimateParameters() {
                try {
                    if (!this.generatedData) {
                        alert('è¯·å…ˆç”Ÿæˆæˆ–ä¸Šä¼ æ•°æ®');
                        return;
                    }
                    
                    const estimationMethod = document.getElementById('estimation-method').value;
                    const resultsGrid = document.getElementById('estimation-results-grid');
                    const resultsContainer = document.getElementById('parameter-estimation-results');
                    
                    if (resultsGrid) {
                        resultsGrid.innerHTML = '';
                    }
                    
                    // è®¡ç®—åŸºæœ¬ç»Ÿè®¡é‡
                    const mean = this.generatedData.reduce((sum, val) => sum + val, 0) / this.generatedData.length;
                    const variance = this.generatedData.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / this.generatedData.length;
                    const stdDev = Math.sqrt(variance);
                    
                    // æ ¹æ®é€‰æ‹©çš„æ–¹æ³•è¿›è¡Œå‚æ•°ä¼°è®¡
                    let params;
                    let methodName;
                    
                    if (estimationMethod === 'mom') {
                        // çŸ©ä¼°è®¡æ³•
                        methodName = 'çŸ©ä¼°è®¡æ³•(MOM)';
                        // æ­£æ€åˆ†å¸ƒçš„çŸ©ä¼°è®¡å‚æ•°
                        params = {
                            'å‡å€¼ (Î¼)': mean.toFixed(4),
                            'æ ‡å‡†å·® (Ïƒ)': stdDev.toFixed(4),
                            'æ–¹å·® (ÏƒÂ²)': variance.toFixed(4)
                        };
                    } else if (estimationMethod === 'mle') {
                        // æœ€å¤§ä¼¼ç„¶ä¼°è®¡æ³•
                        methodName = 'æœ€å¤§ä¼¼ç„¶ä¼°è®¡æ³•(MLE)';
                        // æ­£æ€åˆ†å¸ƒçš„MLEå‚æ•°ï¼ˆå¯¹äºæ­£æ€åˆ†å¸ƒï¼ŒMLEä¸MOMç»“æœç›¸åŒï¼‰
                        params = {
                            'å‡å€¼ (Î¼)': mean.toFixed(4),
                            'æ ‡å‡†å·® (Ïƒ)': stdDev.toFixed(4),
                            'æ–¹å·® (ÏƒÂ²)': variance.toFixed(4)
                        };
                    }
                    
                    // æ˜¾ç¤ºä¼°è®¡æ–¹æ³•åç§°
                    const methodHeader = document.createElement('div');
                    methodHeader.className = 'estimation-method-header';
                    methodHeader.style.cssText = `
                        grid-column: 1 / -1;
                        font-weight: bold;
                        color: var(--primary-color);
                        margin-bottom: 10px;
                        text-align: center;
                        padding: 5px;
                        border-bottom: 2px solid var(--primary-color);
                    `;
                    methodHeader.textContent = `ä½¿ç”¨${methodName}ä¼°è®¡çš„å‚æ•°`;
                    
                    if (resultsGrid) {
                        resultsGrid.appendChild(methodHeader);
                    }
                    
                    // åˆ›å»ºå‚æ•°ä¼°è®¡ç»“æœå¡ç‰‡
                    Object.entries(params).forEach(([label, value]) => {
                        const card = document.createElement('div');
                        card.className = 'stat-card';
                        card.style.cssText = `
                            background-color: var(--card-background);
                            border: 1px solid var(--border-color);
                            border-radius: 6px;
                            padding: 12px;
                            box-shadow: var(--shadow);
                            text-align: center;
                        `;
                        
                        const labelElem = document.createElement('div');
                        labelElem.style.cssText = `
                            font-size: 14px;
                            color: var(--text-secondary);
                            margin-bottom: 5px;
                        `;
                        labelElem.textContent = label;
                        
                        const valueElem = document.createElement('div');
                        valueElem.style.cssText = `
                            font-size: 18px;
                            font-weight: bold;
                            color: var(--text-primary);
                        `;
                        valueElem.textContent = value;
                        
                        card.appendChild(labelElem);
                        card.appendChild(valueElem);
                        
                        if (resultsGrid) {
                            resultsGrid.appendChild(card);
                        }
                    });
                    
                    // æ˜¾ç¤ºç»“æœå®¹å™¨
                    if (resultsContainer) {
                        resultsContainer.classList.remove('hidden');
                    }
                    
                } catch (error) {
                    console.error('å‚æ•°ä¼°è®¡æ—¶å‡ºé”™:', error);
                    alert('å‚æ•°ä¼°è®¡å¤±è´¥: ' + error.message);
                }
            },
            
            // åˆå§‹åŒ–AIé›†æˆ
            initAIIntegration() {
                console.log('åˆå§‹åŒ–AIé›†æˆ');
                try {
                    // åˆ›å»ºDashScopeé›†æˆå®ä¾‹
                    this.ai = new DashScopeIntegration();
                    // å°è¯•åŠ è½½ä¿å­˜çš„APIå¯†é’¥
                    this.ai.loadApiKey();
                    
                    // æ·»åŠ AIè®¾ç½®æŒ‰é’®
                    this.addAISettingsButton();
                } catch (error) {
                    console.warn('AIé›†æˆåˆå§‹åŒ–å¤±è´¥:', error);
                    // ç»§ç»­ä½¿ç”¨æ¨¡æ‹ŸAIä½œä¸ºåå¤‡
                }
            },
            
            // æ·»åŠ AIè®¾ç½®æŒ‰é’®
            addAISettingsButton() {
                const aiInputContainer = document.getElementById('ai-data-input');
                if (aiInputContainer) {
                    const settingsButton = document.createElement('button');
                    settingsButton.id = 'ai-settings-button';
                    settingsButton.className = 'btn btn-outline-secondary';
                    settingsButton.style = 'margin-left: 10px;';
                    settingsButton.textContent = 'ğŸ¤– AIè®¾ç½®';
                    settingsButton.onclick = () => this.showAISetup();
                    
                    const generateButton = document.getElementById('generate-ai-data');
                    if (generateButton) {
                        generateButton.parentNode.insertBefore(settingsButton, generateButton.nextSibling);
                    }
                }
            },
            
            // æ˜¾ç¤ºAIè®¾ç½®æ¨¡æ€æ¡†
            showAISetup() {
                // åˆ›å»ºæ¨¡æ€æ¡†
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background-color: rgba(0, 0, 0, 0.5);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 1000;
                `;
                
                modal.innerHTML = `
                    <div style="
                        background-color: white;
                        border-radius: 8px;
                        padding: 20px;
                        width: 90%;
                        max-width: 500px;
                        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
                    ">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                            <h3 style="margin: 0;">ğŸ¤– AI æ•°æ®ç”Ÿæˆè®¾ç½®</h3>
                            <button id="close-modal" style="
                                background: none;
                                border: none;
                                font-size: 24px;
                                cursor: pointer;
                                color: #666;
                            ">Ã—</button>
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: bold;">DashScope API å¯†é’¥</label>
                            <input type="password" id="api-key-input" style="
                                width: 100%;
                                padding: 10px;
                                border: 1px solid #ddd;
                                border-radius: 4px;
                                font-size: 14px;
                            " placeholder="è¾“å…¥æ‚¨çš„ DashScope API å¯†é’¥">
                            <p style="font-size: 12px; color: #666; margin-top: 5px;">
                                ä» <a href="https://dashscope.aliyun.com" target="_blank">é˜¿é‡Œäº‘ DashScope</a> è·å–APIå¯†é’¥
                            </p>
                        </div>
                        
                        <div style="margin-bottom: 15px;">
                            <button id="test-connection" style="
                                background-color: #4a6fa5;
                                color: white;
                                border: none;
                                padding: 10px 20px;
                                border-radius: 4px;
                                cursor: pointer;
                                margin-right: 10px;
                            ">æµ‹è¯•è¿æ¥</button>
                            <button id="save-api-key" style="
                                background-color: #4caf50;
                                color: white;
                                border: none;
                                padding: 10px 20px;
                                border-radius: 4px;
                                cursor: pointer;
                            ">ä¿å­˜ & ä½¿ç”¨ AI</button>
                        </div>
                        
                        <div id="connection-status" style="
                            padding: 10px;
                            border-radius: 4px;
                            display: none;
                            font-size: 14px;
                        "></div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // å…³é—­æ¨¡æ€æ¡†
                document.getElementById('close-modal').onclick = () => {
                    document.body.removeChild(modal);
                };
                
                // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
                modal.onclick = (e) => {
                    if (e.target === modal) {
                        document.body.removeChild(modal);
                    }
                };
                
                // æµ‹è¯•è¿æ¥
                document.getElementById('test-connection').onclick = async () => {
                    const apiKey = document.getElementById('api-key-input').value;
                    const statusDiv = document.getElementById('connection-status');
                    
                    if (!apiKey) {
                        statusDiv.textContent = 'è¯·è¾“å…¥APIå¯†é’¥';
                        statusDiv.style.backgroundColor = '#ffebee';
                        statusDiv.style.color = '#c62828';
                        statusDiv.style.display = 'block';
                        return;
                    }
                    
                    statusDiv.textContent = 'æ­£åœ¨æµ‹è¯•è¿æ¥...';
                    statusDiv.style.backgroundColor = '#e3f2fd';
                    statusDiv.style.color = '#1565c0';
                    statusDiv.style.display = 'block';
                    
                    try {
                        this.ai.setApiKey(apiKey);
                        const result = await this.ai.testConnection();
                        
                        if (result.success) {
                            statusDiv.textContent = 'âœ… è¿æ¥æˆåŠŸï¼';
                            statusDiv.style.backgroundColor = '#e8f5e9';
                            statusDiv.style.color = '#2e7d32';
                        } else {
                            statusDiv.textContent = `âŒ è¿æ¥å¤±è´¥: ${result.message}`;
                            statusDiv.style.backgroundColor = '#ffebee';
                            statusDiv.style.color = '#c62828';
                        }
                    } catch (error) {
                        statusDiv.textContent = `âŒ é”™è¯¯: ${error.message}`;
                        statusDiv.style.backgroundColor = '#ffebee';
                        statusDiv.style.color = '#c62828';
                    }
                };
                
                // ä¿å­˜APIå¯†é’¥
                document.getElementById('save-api-key').onclick = () => {
                    const apiKey = document.getElementById('api-key-input').value;
                    if (apiKey) {
                        this.ai.setApiKey(apiKey);
                        
                        const statusDiv = document.getElementById('connection-status');
                        statusDiv.textContent = 'âœ… APIå¯†é’¥å·²ä¿å­˜ï¼';
                        statusDiv.style.backgroundColor = '#e8f5e9';
                        statusDiv.style.color = '#2e7d32';
                        statusDiv.style.display = 'block';
                        
                        // å»¶è¿Ÿå…³é—­æ¨¡æ€æ¡†
                        setTimeout(() => {
                            document.body.removeChild(modal);
                        }, 1500);
                    }
                };
            },
            
            // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
            setupEventListeners() {
                console.log('è®¾ç½®äº‹ä»¶ç›‘å¬å™¨...');
                try {
                    // æ¦‚ç‡åˆ†å¸ƒæ¨¡æ‹Ÿç›¸å…³äº‹ä»¶
                    const generateDataBtn = document.getElementById('generate-data');
                    const clearDataBtn = document.getElementById('clear-data');
                    
                    console.log('ç”Ÿæˆæ•°æ®æŒ‰é’®:', generateDataBtn);
                    if (generateDataBtn) {
                        generateDataBtn.addEventListener('click', () => {
                            console.log('ç‚¹å‡»ç”Ÿæˆæ•°æ®æŒ‰é’®');
                            this.generateDistributionData();
                        });
                    }
                    
                    if (clearDataBtn) {
                        clearDataBtn.addEventListener('click', () => this.clearDistributionData());
                    }
                    
                    // ç½®ä¿¡åŒºé—´åˆ†æç›¸å…³äº‹ä»¶
                    const calculateConfidenceBtn = document.getElementById('calculate-confidence');
                    const generateConfidenceSampleBtn = document.getElementById('generate-confidence-sample');
                    
                    if (calculateConfidenceBtn) {
                        calculateConfidenceBtn.addEventListener('click', () => this.calculateConfidenceInterval());
                    }
                    
                    if (generateConfidenceSampleBtn) {
                        generateConfidenceSampleBtn.addEventListener('click', () => this.generateConfidenceSample());
                    }
                    
                    // æ•°æ®åˆ†æç›¸å…³äº‹ä»¶
                    const analyzeDataBtn = document.getElementById('analyze-data');
                    const resetAnalysisBtn = document.getElementById('reset-analysis');
                    const fileUpload = document.getElementById('file-upload');
                    
                    if (analyzeDataBtn) {
                        analyzeDataBtn.addEventListener('click', () => this.analyzeData());
                    }
                    
                    if (resetAnalysisBtn) {
                        resetAnalysisBtn.addEventListener('click', () => this.resetAnalysis());
                    }
                    
                    if (fileUpload) {
                        fileUpload.addEventListener('change', (e) => this.handleFileUpload(e));
                    }
                    
                    // è®¾ç½®æ•°æ®è¾“å…¥æ–¹å¼åˆ‡æ¢äº‹ä»¶
                    document.querySelectorAll('input[name="data-input-method"]').forEach(radio => {
                        radio.addEventListener('change', () => this.switchDataInputMethod());
                    });
                    
                    // è®¾ç½®AIç”Ÿæˆæ•°æ®æŒ‰é’®äº‹ä»¶
                    const generateAIDataBtn = document.getElementById('generate-ai-data');
                    if (generateAIDataBtn) {
                        generateAIDataBtn.addEventListener('click', () => {
                            console.log('ç‚¹å‡»ç”ŸæˆAIæ•°æ®æŒ‰é’®');
                            this.generateAIData();
                        });
                    }
                    
                    console.log('äº‹ä»¶ç›‘å¬å™¨è®¾ç½®å®Œæˆ');
                } catch (error) {
                    console.error('è®¾ç½®äº‹ä»¶ç›‘å¬å™¨æ—¶å‡ºé”™:', error);
                    alert('è®¾ç½®äº‹ä»¶ç›‘å¬å™¨å¤±è´¥: ' + error.message);
                }
            },
            
            // è®¾ç½®æ ‡ç­¾é¡µåˆ‡æ¢
            setupTabs() {
                try {
                    const tabs = document.querySelectorAll('.tab');
                    tabs.forEach(tab => {
                        tab.addEventListener('click', () => {
                            const tabId = tab.getAttribute('data-tab');
                            
                            // ç§»é™¤æ‰€æœ‰æ ‡ç­¾çš„æ´»åŠ¨çŠ¶æ€
                            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                            tab.classList.add('active');
                            
                            // éšè—æ‰€æœ‰å†…å®¹
                            document.querySelectorAll('.tab-content').forEach(content => content.classList.add('hidden'));
                            const targetContent = document.getElementById(tabId);
                            if (targetContent) {
                                targetContent.classList.remove('hidden');
                            }
                        });
                    });
                } catch (error) {
                    console.error('è®¾ç½®æ ‡ç­¾é¡µæ—¶å‡ºé”™:', error);
                }
            },
            
            // è®¾ç½®åˆ†å¸ƒç±»å‹å˜åŒ–äº‹ä»¶
            setupDistributionTypeChange() {
                try {
                    const distributionType = document.getElementById('distribution-type');
                    const paramGroups = {
                        'normal': document.getElementById('normal-params'),
                        'binomial': document.getElementById('binomial-params'),
                        'poisson': document.getElementById('poisson-params'),
                        'uniform': document.getElementById('uniform-params'),
                        'exponential': document.getElementById('exponential-params')
                    };
                    
                    if (distributionType) {
                        distributionType.addEventListener('change', () => {
                            const selectedType = distributionType.value;
                            
                            // éšè—æ‰€æœ‰å‚æ•°ç»„
                            for (const type in paramGroups) {
                                if (paramGroups[type]) {
                                    paramGroups[type].classList.add('hidden');
                                }
                            }
                            
                            // æ˜¾ç¤ºé€‰ä¸­çš„å‚æ•°ç»„
                            if (paramGroups[selectedType]) {
                                paramGroups[selectedType].classList.remove('hidden');
                            }
                        });
                    }
                } catch (error) {
                    console.error('è®¾ç½®åˆ†å¸ƒç±»å‹å˜åŒ–æ—¶å‡ºé”™:', error);
                }
            },
            
            // è®¾ç½®å›¾è¡¨ç±»å‹å˜åŒ–ç›‘å¬å™¨
            setupChartTypeChangeListener() {
                try {
                    const chartTypeSelect = document.getElementById('chart-type');
                    
                    // ç¡®ä¿åªæ·»åŠ ä¸€æ¬¡äº‹ä»¶ç›‘å¬å™¨
                    if (chartTypeSelect && !chartTypeSelect.getAttribute('data-listener-added')) {
                        chartTypeSelect.addEventListener('change', () => {
                            // å½“å›¾è¡¨ç±»å‹æ”¹å˜æ—¶ï¼Œå¦‚æœå·²ç»æœ‰åˆ†æç»“æœï¼Œé‡æ–°ç»˜åˆ¶å›¾è¡¨
                            if (this.currentChart && this.generatedData) {
                                this.updateChart();
                            }
                        });
                        
                        // æ ‡è®°å·²æ·»åŠ ç›‘å¬å™¨
                        chartTypeSelect.setAttribute('data-listener-added', 'true');
                    }
                } catch (error) {
                    console.error('è®¾ç½®å›¾è¡¨ç±»å‹å˜åŒ–ç›‘å¬å™¨æ—¶å‡ºé”™:', error);
                }
            },
            
            // ç”Ÿæˆåˆ†å¸ƒæ•°æ®
            generateDistributionData() {
                console.log('å¼€å§‹ç”Ÿæˆåˆ†å¸ƒæ•°æ®...');
                try {
                    // è·å–å¹¶éªŒè¯å…ƒç´ å­˜åœ¨æ€§
                    const distributionTypeElement = document.getElementById('distribution-type');
                    const sampleSizeElement = document.getElementById('sample-size');
                    
                    if (!distributionTypeElement || !sampleSizeElement) {
                        throw new Error('æ‰¾ä¸åˆ°å¿…è¦çš„DOMå…ƒç´ ');
                    }
                    
                    const distributionType = distributionTypeElement.value;
                    const sampleSize = parseInt(sampleSizeElement.value);
                    
                    console.log('åˆ†å¸ƒç±»å‹:', distributionType);
                    console.log('æ ·æœ¬å¤§å°:', sampleSize);
                    
                    // éªŒè¯æ ·æœ¬å¤§å°
                    if (isNaN(sampleSize) || sampleSize < 100 || sampleSize > 10000) {
                        alert('è¯·è¾“å…¥æœ‰æ•ˆçš„æ ·æœ¬å¤§å°ï¼ˆ100-10000ï¼‰');
                        return;
                    }
                    
                    // æ˜¾ç¤ºè¿›åº¦æ¡
                    const progressContainer = document.getElementById('generation-progress');
                    const progressFill = progressContainer ? progressContainer.querySelector('.progress-fill') : null;
                    const progressText = progressContainer ? progressContainer.querySelector('.progress-text') : null;
                    
                    if (progressContainer && progressFill && progressText) {
                        progressContainer.classList.remove('hidden');
                        progressFill.style.width = '0%';
                        progressText.textContent = 'æ­£åœ¨ç”Ÿæˆæ•°æ®...';
                    }
                    
                    // æ¨¡æ‹Ÿç”Ÿæˆè¿‡ç¨‹ä¸­çš„è¿›åº¦æ›´æ–°
                    let progress = 0;
                    const interval = setInterval(() => {
                        progress += 5;
                        if (progressFill && progressText) {
                            progressFill.style.width = `${Math.min(progress, 90)}%`;
                            progressText.textContent = `æ­£åœ¨ç”Ÿæˆæ•°æ®... ${progress}%`;
                        }
                        
                        if (progress >= 100) {
                            clearInterval(interval);
                        }
                    }, 50);
                    
                    // æ ¹æ®ä¸åŒåˆ†å¸ƒç±»å‹ç”Ÿæˆæ•°æ® - ä½¿ç”¨Promiseç¡®ä¿å¼‚æ­¥æ“ä½œçš„æ­£ç¡®æ€§
                    Promise.resolve().then(() => {
                        try {
                            let data = null;
                            
                            switch (distributionType) {
                                case 'normal':
                                    console.log('ç”Ÿæˆæ­£æ€åˆ†å¸ƒæ•°æ®');
                                    data = this.generateNormalData(sampleSize);
                                    break;
                                case 'binomial':
                                    console.log('ç”ŸæˆäºŒé¡¹åˆ†å¸ƒæ•°æ®');
                                    data = this.generateBinomialData(sampleSize);
                                    break;
                                case 'poisson':
                                    console.log('ç”Ÿæˆæ³Šæ¾åˆ†å¸ƒæ•°æ®');
                                    data = this.generatePoissonData(sampleSize);
                                    break;
                                case 'uniform':
                                    console.log('ç”Ÿæˆå‡åŒ€åˆ†å¸ƒæ•°æ®');
                                    data = this.generateUniformData(sampleSize);
                                    break;
                                case 'exponential':
                                    console.log('ç”ŸæˆæŒ‡æ•°åˆ†å¸ƒæ•°æ®');
                                    data = this.generateExponentialData(sampleSize);
                                    break;
                                default:
                                    throw new Error('æœªçŸ¥çš„åˆ†å¸ƒç±»å‹');
                            }
                            
                            // ç¡®ä¿æ•°æ®ç”ŸæˆæˆåŠŸ
                            if (!data || data.length === 0) {
                                throw new Error('æ•°æ®ç”Ÿæˆå¤±è´¥ï¼Œè¿”å›ç©ºæ•°æ®');
                            }
                            
                            console.log('æ•°æ®ç”ŸæˆæˆåŠŸï¼Œé•¿åº¦:', data.length);
                            this.generatedData = data;
                            
                            // æ›´æ–°è¿›åº¦æ¡ä¸º100%
                            if (progressFill && progressText) {
                                progressFill.style.width = '100%';
                                progressText.textContent = 'æ•°æ®ç”Ÿæˆå®Œæˆï¼';
                            }
                            
                            // ç»˜åˆ¶å›¾è¡¨
                            console.log('å¼€å§‹ç»˜åˆ¶å›¾è¡¨');
                            this.plotDistributionChart(data, distributionType);
                            
                            // è®¡ç®—å¹¶æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
                            console.log('å¼€å§‹è®¡ç®—ç»Ÿè®¡ä¿¡æ¯');
                            this.calculateDistributionStats(data, distributionType);
                            
                            // éšè—è¿›åº¦æ¡
                            setTimeout(() => {
                                if (progressContainer) {
                                    progressContainer.classList.add('hidden');
                                }
                            }, 500);
                        } catch (error) {
                            console.error('ç”Ÿæˆæ•°æ®æ—¶å‡ºé”™:', error);
                            alert('ç”Ÿæˆæ•°æ®æ—¶å‡ºé”™: ' + error.message);
                            if (progressContainer) {
                                progressContainer.classList.add('hidden');
                            }
                        } finally {
                            clearInterval(interval);
                        }
                    });
                } catch (error) {
                    console.error('è°ƒç”¨ç”Ÿæˆæ•°æ®å‡½æ•°æ—¶å‡ºé”™:', error);
                    alert('ç”Ÿæˆæ•°æ®å¤±è´¥: ' + error.message);
                }
            },
            
            // ç”Ÿæˆæ­£æ€åˆ†å¸ƒæ•°æ®
            generateNormalData(sampleSize) {
                const mean = parseFloat(document.getElementById('normal-mean').value);
                const std = parseFloat(document.getElementById('normal-std').value);
                
                // éªŒè¯å‚æ•°
                if (isNaN(mean) || isNaN(std) || std <= 0) {
                    throw new Error('æ— æ•ˆçš„æ­£æ€åˆ†å¸ƒå‚æ•°');
                }
                
                const data = [];
                
                for (let i = 0; i < sampleSize; i++) {
                    // Box-Muller è½¬æ¢ç”Ÿæˆæ­£æ€åˆ†å¸ƒéšæœºæ•°
                    let u1, u2;
                    do {
                        u1 = Math.random();
                        u2 = Math.random();
                    } while (u1 <= Number.EPSILON);
                    
                    const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                    data.push(mean + z0 * std);
                }
                
                return data;
            },
            
            // ç”ŸæˆäºŒé¡¹åˆ†å¸ƒæ•°æ®
            generateBinomialData(sampleSize) {
                const n = parseInt(document.getElementById('binomial-n').value);
                const p = parseFloat(document.getElementById('binomial-p').value);
                
                // éªŒè¯å‚æ•°
                if (isNaN(n) || isNaN(p) || n <= 0 || p < 0 || p > 1) {
                    throw new Error('æ— æ•ˆçš„äºŒé¡¹åˆ†å¸ƒå‚æ•°');
                }
                
                const data = [];
                
                for (let i = 0; i < sampleSize; i++) {
                    let successes = 0;
                    for (let j = 0; j < n; j++) {
                        if (Math.random() < p) {
                            successes++;
                        }
                    }
                    data.push(successes);
                }
                
                return data;
            },
            
            // ç”Ÿæˆæ³Šæ¾åˆ†å¸ƒæ•°æ®
            generatePoissonData(sampleSize) {
                const lambda = parseFloat(document.getElementById('poisson-lambda').value);
                
                // éªŒè¯å‚æ•°
                if (isNaN(lambda) || lambda <= 0) {
                    throw new Error('æ— æ•ˆçš„æ³Šæ¾åˆ†å¸ƒå‚æ•°');
                }
                
                const data = [];
                
                for (let i = 0; i < sampleSize; i++) {
                    let k = 0;
                    let p = 1;
                    const L = Math.exp(-lambda);
                    
                    do {
                        k++;
                        p *= Math.random();
                    } while (p > L);
                    
                    data.push(k - 1);
                }
                
                return data;
            },
            
            // ç”Ÿæˆå‡åŒ€åˆ†å¸ƒæ•°æ®
            generateUniformData(sampleSize) {
                const min = parseFloat(document.getElementById('uniform-min').value);
                const max = parseFloat(document.getElementById('uniform-max').value);
                
                // éªŒè¯å‚æ•°
                if (isNaN(min) || isNaN(max) || min >= max) {
                    throw new Error('æ— æ•ˆçš„å‡åŒ€åˆ†å¸ƒå‚æ•°');
                }
                
                const data = [];
                
                for (let i = 0; i < sampleSize; i++) {
                    data.push(min + Math.random() * (max - min));
                }
                
                return data;
            },
            
            // ç”ŸæˆæŒ‡æ•°åˆ†å¸ƒæ•°æ®
            generateExponentialData(sampleSize) {
                const lambda = parseFloat(document.getElementById('exponential-lambda').value);
                
                // éªŒè¯å‚æ•°
                if (isNaN(lambda) || lambda <= 0) {
                    throw new Error('æ— æ•ˆçš„æŒ‡æ•°åˆ†å¸ƒå‚æ•°');
                }
                
                const data = [];
                
                for (let i = 0; i < sampleSize; i++) {
                    // é€†å˜æ¢æ³•ç”ŸæˆæŒ‡æ•°åˆ†å¸ƒ
                    const u = Math.random();
                    data.push(-Math.log(1 - u) / lambda);
                }
                
                return data;
            },
            
            // ç»˜åˆ¶åˆ†å¸ƒå›¾è¡¨
            plotDistributionChart(data, distributionType) {
                console.log('ç»˜åˆ¶åˆ†å¸ƒå›¾è¡¨');
                try {
                    const chartElement = document.getElementById('distribution-chart');
                    const chartContainer = document.getElementById('distribution-chart-container');
                    
                    if (!chartElement || !chartContainer) {
                        throw new Error('æ‰¾ä¸åˆ°å›¾è¡¨ç›¸å…³çš„DOMå…ƒç´ ');
                    }
                    
                    const ctx = chartElement.getContext('2d');
                    
                    // æ˜¾ç¤ºå›¾è¡¨å®¹å™¨
                    chartContainer.classList.remove('hidden');
                    
                    // é”€æ¯æ—§å›¾è¡¨
                    if (this.currentChart) {
                        console.log('é”€æ¯æ—§å›¾è¡¨');
                        this.currentChart.destroy();
                        this.currentChart = null;
                    }
                    
                    // è®¡ç®—ç›´æ–¹å›¾æ•°æ®
                    const binCount = Math.min(Math.ceil(Math.sqrt(data.length)), 50);
                    const min = Math.min(...data);
                    const max = Math.max(...data);
                    const binWidth = (max - min) / binCount;
                    
                    const bins = Array(binCount).fill(0);
                    const binLabels = [];
                    
                    for (let i = 0; i < binCount; i++) {
                        binLabels.push((min + i * binWidth).toFixed(2));
                    }
                    
                    data.forEach(value => {
                        if (value >= min && value <= max) {
                            const binIndex = Math.min(Math.floor((value - min) / binWidth), binCount - 1);
                            bins[binIndex]++;
                        }
                    });
                    
                    // å½’ä¸€åŒ–é¢‘ç‡
                    const frequencies = bins.map(count => count / data.length);
                    
                    console.log('å‡†å¤‡åˆ›å»ºå›¾è¡¨');
                    // åˆ›å»ºå›¾è¡¨
                    this.currentChart = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: binLabels,
                            datasets: [{
                                label: `${this.getDistributionName(distributionType)}åˆ†å¸ƒé¢‘ç‡`,
                                data: frequencies,
                                backgroundColor: 'rgba(74, 111, 165, 0.7)',
                                borderColor: 'rgba(74, 111, 165, 1)',
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: {
                                    title: {
                                        display: true,
                                        text: 'å€¼'
                                    },
                                    ticks: {
                                        autoSkip: true,
                                        maxRotation: 0,
                                        callback: function(value, index, values) {
                                            // åªæ˜¾ç¤ºéƒ¨åˆ†æ ‡ç­¾ä»¥é¿å…æ‹¥æŒ¤
                                            return index % Math.ceil(binCount / 20) === 0 ? this.getLabelForValue(value) : '';
                                        }
                                    }
                                },
                                y: {
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: 'é¢‘ç‡'
                                    },
                                    ticks: {
                                        callback: function(value) {
                                            return value.toFixed(3);
                                        }
                                    }
                                }
                            },
                            plugins: {
                                title: {
                                    display: true,
                                    text: `${this.getDistributionName(distributionType)}åˆ†å¸ƒç›´æ–¹å›¾ (æ ·æœ¬å¤§å°: ${data.length})`,
                                    font: {
                                        size: 16
                                    }
                                },
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            const value = context.raw;
                                            const count = Math.round(value * data.length);
                                            return `é¢‘ç‡: ${value.toFixed(4)} (è®¡æ•°: ${count})`;
                                        }
                                    }
                                }
                            }
                        }
                    });
                    
                    console.log('å›¾è¡¨ç»˜åˆ¶å®Œæˆ');
                } catch (error) {
                    console.error('ç»˜åˆ¶å›¾è¡¨æ—¶å‡ºé”™:', error);
                    alert('ç»˜åˆ¶å›¾è¡¨å¤±è´¥: ' + error.message);
                }
            },
            
            // è®¡ç®—åˆ†å¸ƒç»Ÿè®¡ä¿¡æ¯
            calculateDistributionStats(data, distributionType) {
                try {
                    const statsContainer = document.getElementById('distribution-stats');
                    
                    if (statsContainer) {
                        statsContainer.innerHTML = '';
                        statsContainer.classList.remove('hidden');
                    }
                    
                    // è®¡ç®—ç»Ÿè®¡é‡
                    const mean = data.reduce((sum, val) => sum + val, 0) / data.length;
                    const sortedData = [...data].sort((a, b) => a - b);
                    const median = sortedData.length % 2 === 0
                        ? (sortedData[sortedData.length / 2 - 1] + sortedData[sortedData.length / 2]) / 2
                        : sortedData[Math.floor(sortedData.length / 2)];
                    
                    const variance = data.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / data.length;
                    const std = Math.sqrt(variance);
                    const min = Math.min(...data);
                    const max = Math.max(...data);
                    
                    // è®¡ç®—å››åˆ†ä½æ•°
                    const q1Index = Math.floor(sortedData.length * 0.25);
                    const q3Index = Math.floor(sortedData.length * 0.75);
                    const q1 = sortedData[q1Index];
                    const q3 = sortedData[q3Index];
                    const iqr = q3 - q1;
                    
                    // åˆ›å»ºç»Ÿè®¡å¡ç‰‡
                    const stats = [
                        { label: 'å‡å€¼', value: mean.toFixed(4) },
                        { label: 'ä¸­ä½æ•°', value: median.toFixed(4) },
                        { label: 'æ ‡å‡†å·®', value: std.toFixed(4) },
                        { label: 'æ–¹å·®', value: variance.toFixed(4) },
                        { label: 'æœ€å°å€¼', value: min.toFixed(4) },
                        { label: 'æœ€å¤§å€¼', value: max.toFixed(4) },
                        { label: 'ç¬¬ä¸€å››åˆ†ä½æ•°', value: q1.toFixed(4) },
                        { label: 'ç¬¬ä¸‰å››åˆ†ä½æ•°', value: q3.toFixed(4) },
                        { label: 'å››åˆ†ä½è·', value: iqr.toFixed(4) }
                    ];
                    
                    // æ·»åŠ ç»Ÿè®¡å¡ç‰‡åˆ°å®¹å™¨
                    stats.forEach(stat => {
                        const card = document.createElement('div');
                        card.className = 'stat-card';
                        
                        const label = document.createElement('div');
                        label.className = 'stat-label';
                        label.textContent = stat.label;
                        
                        const value = document.createElement('div');
                        value.className = 'stat-value';
                        value.textContent = stat.value;
                        
                        card.appendChild(label);
                        card.appendChild(value);
                        
                        if (statsContainer) {
                            statsContainer.appendChild(card);
                        }
                    });
                } catch (error) {
                    console.error('è®¡ç®—ç»Ÿè®¡ä¿¡æ¯æ—¶å‡ºé”™:', error);
                }
            },
            
            // æ¸…é™¤åˆ†å¸ƒæ•°æ®
            clearDistributionData() {
                try {
                    // é”€æ¯å›¾è¡¨
                    if (this.currentChart) {
                        this.currentChart.destroy();
                        this.currentChart = null;
                    }
                    
                    // éšè—å›¾è¡¨å’Œç»Ÿè®¡ä¿¡æ¯
                    const chartContainer = document.getElementById('distribution-chart-container');
                    const statsContainer = document.getElementById('distribution-stats');
                    
                    if (chartContainer) {
                        chartContainer.classList.add('hidden');
                    }
                    
                    if (statsContainer) {
                        statsContainer.classList.add('hidden');
                    }
                    
                    // æ¸…é™¤æ•°æ®
                    this.generatedData = null;
                } catch (error) {
                    console.error('æ¸…é™¤æ•°æ®æ—¶å‡ºé”™:', error);
                }
            },
            
            // åˆå§‹åŒ–ç½®ä¿¡åŒºé—´åˆ†æäº‹ä»¶ç›‘å¬å™¨
            initConfidenceIntervalEvents() {
                // æ•°æ®è¾“å…¥æ–¹å¼åˆ‡æ¢
                const dataMethods = document.querySelectorAll('input[name="confidence-data-method"]');
                dataMethods.forEach(method => {
                    method.addEventListener('change', () => this.toggleConfidenceDataSections());
                });
                
                // æ£€éªŒæ–¹æ³•åˆ‡æ¢
                document.getElementById('confidence-test-type').addEventListener('change', () => {
                    const stdSection = document.getElementById('sample-std-section');
                    const testType = document.getElementById('confidence-test-type').value;
                    stdSection.classList.toggle('hidden', testType !== 'z-test');
                });
                
                // è®¡ç®—æ ·æœ¬é‡æŒ‰é’®
                document.getElementById('calculate-sample-size').addEventListener('click', () => {
                    document.getElementById('sample-size-calculator').classList.toggle('hidden');
                });
                
                // æ‰§è¡Œæ ·æœ¬é‡è®¡ç®—
                document.getElementById('compute-sample-size').addEventListener('click', () => {
                    this.calculateRequiredSampleSize();
                });
                
                // æ¸…é™¤ç»“æœæŒ‰é’®
                document.getElementById('clear-confidence-results').addEventListener('click', () => {
                    this.clearConfidenceResults();
                });
                
                // è®¡ç®—ç½®ä¿¡åŒºé—´æŒ‰é’®
                document.getElementById('calculate-confidence').addEventListener('click', () => {
                    this.calculateConfidenceInterval();
                });
                
                // ç”Ÿæˆæ ·æœ¬å¹¶åˆ†ææŒ‰é’®
                document.getElementById('generate-confidence-sample').addEventListener('click', () => {
                    this.generateConfidenceSample();
                });
                
                // åˆå§‹åŒ–æ˜¾ç¤ºæ­£ç¡®çš„éƒ¨åˆ†
                this.toggleConfidenceDataSections();
            },
            
            // åˆ‡æ¢ç½®ä¿¡åŒºé—´æ•°æ®è¾“å…¥éƒ¨åˆ†
            toggleConfidenceDataSections() {
                const method = document.querySelector('input[name="confidence-data-method"]:checked').value;
                
                document.getElementById('sample-data-section').classList.toggle('hidden', method !== 'sample');
                document.getElementById('population-data-section').classList.toggle('hidden', method !== 'population');
                document.getElementById('generate-data-section').classList.toggle('hidden', method !== 'generate');
                
                // å¦‚æœæ˜¯Zæ£€éªŒï¼Œæ˜¾ç¤ºæ€»ä½“æ ‡å‡†å·®è¾“å…¥æ¡†
                const testType = document.getElementById('confidence-test-type')?.value;
                const stdSection = document.getElementById('sample-std-section');
                if (stdSection && testType) {
                    stdSection.classList.toggle('hidden', testType !== 'z-test');
                }
            },
            
            // è®¡ç®—ç½®ä¿¡åŒºé—´
            calculateConfidenceInterval() {
                try {
                    const method = document.querySelector('input[name="confidence-data-method"]:checked').value;
                    let result;
                    
                    switch (method) {
                        case 'sample':
                            result = this.calculateConfidenceFromSample();
                            break;
                        case 'population':
                            result = this.calculateConfidenceFromParameters();
                            break;
                        default:
                            alert('è¯·é€‰æ‹©æœ‰æ•ˆçš„æ•°æ®è¾“å…¥æ–¹å¼');
                            return;
                    }
                    
                    if (result) {
                        this.displayConfidenceResults(result);
                        this.plotConfidenceIntervalChart(result);
                        this.generateInterpretation(result);
                    }
                } catch (error) {
                    console.error('è®¡ç®—ç½®ä¿¡åŒºé—´æ—¶å‡ºé”™:', error);
                    alert('è®¡ç®—ç½®ä¿¡åŒºé—´å¤±è´¥: ' + error.message);
                }
            },
            
            // ä»æ ·æœ¬æ•°æ®è®¡ç®—ç½®ä¿¡åŒºé—´
            calculateConfidenceFromSample() {
                const sampleDataInput = document.getElementById('sample-data').value.trim();
                if (!sampleDataInput) {
                    alert('è¯·è¾“å…¥æ ·æœ¬æ•°æ®');
                    return null;
                }
                
                // è§£ææ ·æœ¬æ•°æ®
                const sampleData = sampleDataInput.split(',').map(val => parseFloat(val.trim())).filter(val => !isNaN(val));
                
                if (sampleData.length === 0) {
                    alert('æ— æ³•è§£ææ ·æœ¬æ•°æ®ï¼Œè¯·ç¡®ä¿æ•°æ®æ ¼å¼æ­£ç¡®');
                    return null;
                }
                
                const testType = document.getElementById('confidence-test-type').value;
                const sampleSize = sampleData.length;
                
                // è®¡ç®—æ ·æœ¬ç»Ÿè®¡é‡
                const sampleMean = sampleData.reduce((sum, val) => sum + val, 0) / sampleSize;
                const sampleVariance = sampleData.reduce((sum, val) => sum + Math.pow(val - sampleMean, 2), 0) / (sampleSize - 1);
                const sampleStd = Math.sqrt(sampleVariance);
                
                // è·å–ç½®ä¿¡æ°´å¹³
                const confidenceLevel = parseFloat(document.getElementById('confidence-level')?.value || 0.95);
                
                let criticalValue, standardError, marginOfError, lowerBound, upperBound;
                
                if (testType === 'z-test') {
                    // Zæ£€éªŒï¼šä½¿ç”¨ç”¨æˆ·æä¾›çš„æ€»ä½“æ ‡å‡†å·®
                    const populationStd = parseFloat(document.getElementById('sample-population-std').value);
                    if (isNaN(populationStd) || populationStd <= 0) {
                        alert('è¯·è¾“å…¥æœ‰æ•ˆçš„æ€»ä½“æ ‡å‡†å·®');
                        return null;
                    }
                    
                    criticalValue = this.getZScore(confidenceLevel);
                    standardError = populationStd / Math.sqrt(sampleSize);
                    marginOfError = criticalValue * standardError;
                    lowerBound = sampleMean - marginOfError;
                    upperBound = sampleMean + marginOfError;
                    
                    return {
                        method: 'Zæ£€éªŒ',
                        confidenceLevel,
                        sampleSize,
                        sampleMean,
                        sampleStd,
                        populationStd,
                        criticalValue,
                        standardError,
                        marginOfError,
                        lowerBound,
                        upperBound,
                        testType: 'z-test',
                        data: sampleData
                    };
                } else {
                    // Tæ£€éªŒï¼šä½¿ç”¨æ ·æœ¬æ ‡å‡†å·®
                    criticalValue = this.getTScore(confidenceLevel, sampleSize - 1);
                    standardError = sampleStd / Math.sqrt(sampleSize);
                    marginOfError = criticalValue * standardError;
                    lowerBound = sampleMean - marginOfError;
                    upperBound = sampleMean + marginOfError;
                    
                    return {
                        method: 'Tæ£€éªŒ',
                        confidenceLevel,
                        sampleSize,
                        sampleMean,
                        sampleStd,
                        degreesOfFreedom: sampleSize - 1,
                        criticalValue,
                        standardError,
                        marginOfError,
                        lowerBound,
                        upperBound,
                        testType: 't-test',
                        data: sampleData
                    };
                }
            },
            
            // ä»å‚æ•°è®¡ç®—ç½®ä¿¡åŒºé—´
            calculateConfidenceFromParameters() {
                const confidenceLevel = parseFloat(document.getElementById('confidence-level').value);
                const sampleMean = parseFloat(document.getElementById('population-mean').value);
                const stdValue = parseFloat(document.getElementById('population-std').value);
                const sampleSize = parseInt(document.getElementById('sample-size-confidence').value);
                const stdType = document.getElementById('std-type').value;
                
                // éªŒè¯å‚æ•°
                if (isNaN(confidenceLevel) || isNaN(sampleMean) || isNaN(stdValue) || isNaN(sampleSize) || 
                    stdValue <= 0 || sampleSize <= 0) {
                    alert('è¯·è¾“å…¥æœ‰æ•ˆçš„å‚æ•°');
                    return null;
                }
                
                let criticalValue, standardError, marginOfError, lowerBound, upperBound, method;
                
                if (stdType === 'population' || sampleSize >= 30) {
                    // Zæ£€éªŒï¼šå·²çŸ¥æ€»ä½“æ ‡å‡†å·®æˆ–å¤§æ ·æœ¬
                    criticalValue = this.getZScore(confidenceLevel);
                    standardError = stdValue / Math.sqrt(sampleSize);
                    marginOfError = criticalValue * standardError;
                    lowerBound = sampleMean - marginOfError;
                    upperBound = sampleMean + marginOfError;
                    method = stdType === 'population' ? 'Zæ£€éªŒ (å·²çŸ¥æ€»ä½“æ ‡å‡†å·®)' : 'Zæ£€éªŒ (å¤§æ ·æœ¬è¿‘ä¼¼)';
                } else {
                    // Tæ£€éªŒï¼šå°æ ·æœ¬ä¸”æœªçŸ¥æ€»ä½“æ ‡å‡†å·®
                    criticalValue = this.getTScore(confidenceLevel, sampleSize - 1);
                    standardError = stdValue / Math.sqrt(sampleSize);
                    marginOfError = criticalValue * standardError;
                    lowerBound = sampleMean - marginOfError;
                    upperBound = sampleMean + marginOfError;
                    method = 'Tæ£€éªŒ (å°æ ·æœ¬ï¼ŒæœªçŸ¥æ€»ä½“æ ‡å‡†å·®)';
                }
                
                return {
                    method,
                    confidenceLevel,
                    sampleSize,
                    sampleMean,
                    [stdType === 'population' ? 'populationStd' : 'sampleStd']: stdValue,
                    criticalValue,
                    standardError,
                    marginOfError,
                    lowerBound,
                    upperBound,
                    testType: stdType === 'population' || sampleSize >= 30 ? 'z-test' : 't-test',
                    degreesOfFreedom: stdType === 'sample' && sampleSize < 30 ? sampleSize - 1 : null
                };
            },
            
            // ç”Ÿæˆç½®ä¿¡åŒºé—´æ ·æœ¬å¹¶åˆ†æ
            generateConfidenceSample() {
                try {
                    const distributionType = document.getElementById('generate-distribution').value;
                    const mean = parseFloat(document.getElementById('generate-mean').value);
                    const std = parseFloat(document.getElementById('generate-std').value);
                    const sampleSize = parseInt(document.getElementById('generate-sample-size').value);
                    const confidenceLevel = parseFloat(document.getElementById('generate-confidence-level').value);
                    
                    // éªŒè¯å‚æ•°
                    if (isNaN(mean) || isNaN(std) || isNaN(sampleSize) || isNaN(confidenceLevel) || 
                        std <= 0 || sampleSize <= 0) {
                        alert('è¯·è¾“å…¥æœ‰æ•ˆçš„å‚æ•°');
                        return;
                    }
                    
                    // ç”Ÿæˆæ ·æœ¬æ•°æ®
                    const sampleData = this.generateConfidenceSampleData(distributionType, sampleSize, mean, std);
                    
                    // è®¡ç®—æ ·æœ¬ç»Ÿè®¡é‡
                    const sampleMean = sampleData.reduce((sum, val) => sum + val, 0) / sampleSize;
                    const sampleVariance = sampleData.reduce((sum, val) => sum + Math.pow(val - sampleMean, 2), 0) / (sampleSize - 1);
                    const sampleStd = Math.sqrt(sampleVariance);
                    
                    // é€‰æ‹©æ£€éªŒæ–¹æ³•
                    let criticalValue, standardError, marginOfError, lowerBound, upperBound, method;
                    
                    if (sampleSize >= 30) {
                        // Zæ£€éªŒï¼šå¤§æ ·æœ¬
                        criticalValue = this.getZScore(confidenceLevel);
                        standardError = sampleStd / Math.sqrt(sampleSize);
                        marginOfError = criticalValue * standardError;
                        lowerBound = sampleMean - marginOfError;
                        upperBound = sampleMean + marginOfError;
                        method = 'Zæ£€éªŒ (å¤§æ ·æœ¬)';
                    } else {
                        // Tæ£€éªŒï¼šå°æ ·æœ¬
                        criticalValue = this.getTScore(confidenceLevel, sampleSize - 1);
                        standardError = sampleStd / Math.sqrt(sampleSize);
                        marginOfError = criticalValue * standardError;
                        lowerBound = sampleMean - marginOfError;
                        upperBound = sampleMean + marginOfError;
                        method = 'Tæ£€éªŒ (å°æ ·æœ¬)';
                    }
                    
                    const result = {
                        method,
                        confidenceLevel,
                        sampleSize,
                        sampleMean,
                        sampleStd,
                        populationMean: mean,
                        populationStd: std,
                        criticalValue,
                        standardError,
                        marginOfError,
                        lowerBound,
                        upperBound,
                        testType: sampleSize >= 30 ? 'z-test' : 't-test',
                        degreesOfFreedom: sampleSize < 30 ? sampleSize - 1 : null,
                        data: sampleData,
                        distributionType
                    };
                    
                    this.displayConfidenceResults(result);
                    this.plotConfidenceIntervalChart(result);
                    this.generateInterpretation(result);
                } catch (error) {
                    console.error('ç”Ÿæˆç½®ä¿¡åŒºé—´æ ·æœ¬æ—¶å‡ºé”™:', error);
                    alert('ç”Ÿæˆæ ·æœ¬å¤±è´¥: ' + error.message);
                }
            },
            
            // è®¡ç®—æ‰€éœ€æ ·æœ¬é‡
            calculateRequiredSampleSize() {
                try {
                    const marginError = parseFloat(document.getElementById('margin-error').value);
                    const confidenceLevel = parseFloat(document.getElementById('ss-confidence-level').value);
                    const populationStd = parseFloat(document.getElementById('ss-population-std').value);
                    
                    // éªŒè¯å‚æ•°
                    if (isNaN(marginError) || isNaN(confidenceLevel) || isNaN(populationStd) || 
                        marginError <= 0 || populationStd <= 0 || confidenceLevel <= 0 || confidenceLevel >= 1) {
                        alert('è¯·è¾“å…¥æœ‰æ•ˆçš„å‚æ•°');
                        return;
                    }
                    
                    // è®¡ç®—Zåˆ†æ•°
                    const zScore = this.getZScore(confidenceLevel);
                    
                    // è®¡ç®—æ ·æœ¬é‡
                    const sampleSize = Math.ceil(Math.pow((zScore * populationStd) / marginError, 2));
                    
                    // æ˜¾ç¤ºç»“æœ
                    const resultContainer = document.getElementById('sample-size-result');
                    resultContainer.innerHTML = '';
                    resultContainer.classList.remove('hidden');
                    
                    const stats = [
                        { label: 'æ‰€éœ€æ ·æœ¬é‡', value: sampleSize },
                        { label: 'ç½®ä¿¡æ°´å¹³', value: `${confidenceLevel * 100}%` },
                        { label: 'è¾¹é™…è¯¯å·®', value: marginError.toFixed(4) },
                        { label: 'æ€»ä½“æ ‡å‡†å·®', value: populationStd.toFixed(4) },
                        { label: 'Zåˆ†æ•°', value: zScore.toFixed(4) }
                    ];
                    
                    stats.forEach(stat => {
                        const card = document.createElement('div');
                        card.className = 'stat-card';
                        
                        const label = document.createElement('div');
                        label.className = 'stat-label';
                        label.textContent = stat.label;
                        
                        const value = document.createElement('div');
                        value.className = 'stat-value';
                        value.textContent = stat.value;
                        
                        card.appendChild(label);
                        card.appendChild(value);
                        resultContainer.appendChild(card);
                    });
                    
                    // æ·»åŠ è§£é‡Šæ–‡æœ¬
                    const explanation = document.createElement('div');
                    explanation.className = 'help-text';
                    explanation.style.marginTop = '15px';
                    explanation.innerHTML = `
                        <p><strong>è§£é‡Šï¼š</strong>è¦è¾¾åˆ°${confidenceLevel * 100}%çš„ç½®ä¿¡æ°´å¹³å’Œ${marginError}çš„è¾¹é™…è¯¯å·®ï¼Œ
                        åœ¨å‡è®¾æ€»ä½“æ ‡å‡†å·®ä¸º${populationStd}çš„æƒ…å†µä¸‹ï¼Œæ‚¨éœ€è¦è‡³å°‘${sampleSize}ä¸ªæ ·æœ¬ã€‚</p>
                    `;
                    resultContainer.appendChild(explanation);
                } catch (error) {
                    console.error('è®¡ç®—æ ·æœ¬é‡æ—¶å‡ºé”™:', error);
                    alert('è®¡ç®—æ ·æœ¬é‡å¤±è´¥: ' + error.message);
                }
            },
            
            // æ˜¾ç¤ºç½®ä¿¡åŒºé—´åˆ†æç»“æœ
            displayConfidenceResults(result) {
                const resultsContainer = document.getElementById('confidence-results');
                const summaryContainer = document.getElementById('confidence-summary');
                
                // æ¸…ç©ºå¹¶æ˜¾ç¤ºå®¹å™¨
                summaryContainer.innerHTML = '';
                resultsContainer.classList.remove('hidden');
                
                // å‡†å¤‡ç»Ÿè®¡æ•°æ®
                const stats = [
                    { label: 'åˆ†ææ–¹æ³•', value: result.method },
                    { label: 'ç½®ä¿¡æ°´å¹³', value: `${result.confidenceLevel * 100}%` },
                    { label: 'æ ·æœ¬å¤§å°', value: result.sampleSize },
                    { label: 'æ ·æœ¬å‡å€¼', value: result.sampleMean.toFixed(4) }
                ];
                
                // æ·»åŠ æ ‡å‡†å·®ä¿¡æ¯
                if (result.populationStd) {
                    stats.push({ label: 'æ€»ä½“æ ‡å‡†å·®', value: result.populationStd.toFixed(4) });
                }
                if (result.sampleStd) {
                    stats.push({ label: 'æ ·æœ¬æ ‡å‡†å·®', value: result.sampleStd.toFixed(4) });
                }
                
                // æ·»åŠ è‡ªç”±åº¦ï¼ˆTæ£€éªŒæ—¶ï¼‰
                if (result.degreesOfFreedom !== null) {
                    stats.push({ label: 'è‡ªç”±åº¦', value: result.degreesOfFreedom });
                }
                
                // æ·»åŠ ä¸´ç•Œå€¼ã€æ ‡å‡†è¯¯å’Œè¾¹é™…è¯¯å·®
                stats.push(
                    { label: 'ä¸´ç•Œå€¼', value: result.criticalValue.toFixed(4) },
                    { label: 'æ ‡å‡†è¯¯', value: result.standardError.toFixed(4) },
                    { label: 'è¾¹é™…è¯¯å·®', value: result.marginOfError.toFixed(4) },
                    { label: 'ç½®ä¿¡åŒºé—´ä¸‹é™', value: result.lowerBound.toFixed(4) },
                    { label: 'ç½®ä¿¡åŒºé—´ä¸Šé™', value: result.upperBound.toFixed(4) }
                );
                
                // åˆ›å»ºç»Ÿè®¡å¡ç‰‡
                stats.forEach(stat => {
                    const card = document.createElement('div');
                    card.className = 'stat-card';
                    
                    const label = document.createElement('div');
                    label.className = 'stat-label';
                    label.textContent = stat.label;
                    
                    const value = document.createElement('div');
                    value.className = 'stat-value';
                    value.textContent = stat.value;
                    
                    card.appendChild(label);
                    card.appendChild(value);
                    summaryContainer.appendChild(card);
                });
                
                // å¦‚æœæœ‰æ€»ä½“å‡å€¼ï¼Œæ·»åŠ é¢å¤–ä¿¡æ¯
                if (result.populationMean !== undefined) {
                    const containsTrueMean = result.lowerBound <= result.populationMean && result.populationMean <= result.upperBound;
                    const meanInfoCard = document.createElement('div');
                    meanInfoCard.className = `stat-card ${containsTrueMean ? 'highlight-accept' : 'highlight-reject'}`;
                    meanInfoCard.innerHTML = `
                        <div class="stat-label">æ€»ä½“å‡å€¼åŒ…å«æƒ…å†µ</div>
                        <div class="stat-value">${containsTrueMean ? 'åŒºé—´åŒ…å«æ€»ä½“å‡å€¼' : 'åŒºé—´ä¸åŒ…å«æ€»ä½“å‡å€¼'}</div>
                        <div class="help-text">å®é™…æ€»ä½“å‡å€¼: ${result.populationMean.toFixed(4)}</div>
                    `;
                    summaryContainer.appendChild(meanInfoCard);
                }
            },
            
            // ç”Ÿæˆç»“æœè§£é‡Š
            generateInterpretation(result) {
                const interpretationContainer = document.getElementById('confidence-interpretation');
                const interpretationText = document.getElementById('interpretation-text');
                
                // è®¡ç®—æ•ˆåº”é‡ï¼ˆCohen's dï¼‰
                let effectSize = null;
                if (result.sampleMean && result.sampleStd) {
                    effectSize = Math.abs(result.sampleMean) / result.sampleStd;
                }
                
                let text = `
                    <p><strong>ç»Ÿè®¡è§£é‡Šï¼š</strong></p>
                    <p>æˆ‘ä»¬æœ‰${result.confidenceLevel * 100}%çš„ä¿¡å¿ƒè®¤ä¸ºï¼ŒçœŸå®æ€»ä½“å‡å€¼è½åœ¨åŒºé—´[${result.lowerBound.toFixed(4)}, ${result.upperBound.toFixed(4)}]å†…ã€‚</p>
                    
                    <p><strong>æ–¹æ³•è®ºè¯´æ˜ï¼š</strong></p>
                    <ul>
                        <li>ä½¿ç”¨äº†${result.method}è¿›è¡Œåˆ†æ</li>
                        <li>åŸºäº${result.sampleSize}ä¸ªæ ·æœ¬çš„è®¡ç®—ç»“æœ</li>
                        <li>è¾¹é™…è¯¯å·®ä¸º${result.marginOfError.toFixed(4)}ï¼Œè¡¨ç¤ºä¼°è®¡çš„ä¸ç¡®å®šæ€§</li>
                    </ul>
                `;
                
                // æ·»åŠ æ•ˆåº”é‡è§£é‡Šï¼ˆå¦‚æœå¯ç”¨ï¼‰
                if (effectSize !== null) {
                    let effectSizeInterpretation = '';
                    if (effectSize < 0.2) effectSizeInterpretation = 'æå°æ•ˆåº”';
                    else if (effectSize < 0.5) effectSizeInterpretation = 'å°æ•ˆåº”';
                    else if (effectSize < 0.8) effectSizeInterpretation = 'ä¸­ç­‰æ•ˆåº”';
                    else effectSizeInterpretation = 'å¤§æ•ˆåº”';
                    
                    text += `
                        <p><strong>æ•ˆåº”é‡åˆ†æï¼š</strong></p>
                        <p>Cohen's d = ${effectSize.toFixed(4)}ï¼ˆ${effectSizeInterpretation}ï¼‰</p>
                    `;
                }
                
                // æ·»åŠ å®é™…åº”ç”¨å»ºè®®
                text += `
                    <p><strong>å®é™…åº”ç”¨å»ºè®®ï¼š</strong></p>
                    <ul>
                        <li>å¦‚æœéœ€è¦æ›´ç²¾ç¡®çš„ä¼°è®¡ï¼Œå¯ä»¥è€ƒè™‘å¢åŠ æ ·æœ¬é‡</li>
                        <li>å½“å‰è¾¹é™…è¯¯å·®ä¸º${result.marginOfError.toFixed(4)}ï¼Œæ‚¨å¯ä»¥æ ¹æ®å®é™…éœ€æ±‚è°ƒæ•´ç½®ä¿¡æ°´å¹³</li>
                        <li>${result.confidenceLevel === 0.95 ? 'å½“å‰ä½¿ç”¨çš„æ˜¯æœ€å¸¸ç”¨çš„95%ç½®ä¿¡æ°´å¹³ï¼Œè¿™åœ¨å¤§å¤šæ•°ç»Ÿè®¡åˆ†æä¸­è¢«è®¤ä¸ºæ˜¯å¹³è¡¡ç²¾ç¡®åº¦å’Œå¯é æ€§çš„åˆç†é€‰æ‹©ã€‚' : 
                          `æ‚¨é€‰æ‹©äº†${result.confidenceLevel * 100}%çš„ç½®ä¿¡æ°´å¹³ï¼Œè¿™æ„å‘³ç€æœ‰${(1 - result.confidenceLevel) * 100}%çš„æ¦‚ç‡åŒºé—´ä¸åŒ…å«çœŸå®æ€»ä½“å‡å€¼ã€‚`}
                        </li>
                    </ul>
                `;
                
                interpretationText.innerHTML = text;
                interpretationContainer.classList.remove('hidden');
            },
            
            // è·å–Zåˆ†æ•°ï¼ˆæ”¯æŒæ›´ç²¾ç¡®çš„è®¡ç®—ï¼‰
            getZScore(confidenceLevel) {
                // ä½¿ç”¨é€†æ­£æ€åˆ†å¸ƒè¿‘ä¼¼
                const alpha = 1 - confidenceLevel;
                const zScore = Math.sqrt(2) * this.erfInv(1 - alpha);
                return Math.abs(zScore);
            },
            
            // è·å–Tåˆ†æ•°ï¼ˆè¿‘ä¼¼è®¡ç®—ï¼‰
            getTScore(confidenceLevel, degreesOfFreedom) {
                // å¯¹äºå¤§è‡ªç”±åº¦ï¼Œä½¿ç”¨Zåˆ†æ•°è¿‘ä¼¼
                if (degreesOfFreedom >= 100) {
                    return this.getZScore(confidenceLevel);
                }
                
                // Tåˆ†å¸ƒä¸´ç•Œå€¼è¿‘ä¼¼è¡¨ï¼ˆåŒä¾§æ£€éªŒï¼‰
                const tTable = {
                    0.90: {
                        1: 6.314, 2: 2.920, 3: 2.353, 4: 2.132, 5: 2.015, 6: 1.943, 7: 1.895, 8: 1.860, 9: 1.833,
                        10: 1.812, 15: 1.753, 20: 1.725, 30: 1.697, 40: 1.684, 50: 1.676, 60: 1.671, 70: 1.667, 80: 1.664,
                        90: 1.662, 99: 1.660
                    },
                    0.95: {
                        1: 12.706, 2: 4.303, 3: 3.182, 4: 2.776, 5: 2.571, 6: 2.447, 7: 2.365, 8: 2.306, 9: 2.262,
                        10: 2.228, 15: 2.131, 20: 2.086, 30: 2.042, 40: 2.021, 50: 2.009, 60: 2.000, 70: 1.994, 80: 1.990,
                        90: 1.987, 99: 1.984
                    },
                    0.99: {
                        1: 63.657, 2: 9.925, 3: 5.841, 4: 4.604, 5: 4.032, 6: 3.707, 7: 3.499, 8: 3.355, 9: 3.250,
                        10: 3.169, 15: 2.947, 20: 2.845, 30: 2.750, 40: 2.704, 50: 2.678, 60: 2.660, 70: 2.648, 80: 2.639,
                        90: 2.632, 99: 2.626
                    }
                };
                
                // æŸ¥æ‰¾æœ€æ¥è¿‘çš„è‡ªç”±åº¦
                if (tTable[confidenceLevel] && tTable[confidenceLevel][degreesOfFreedom]) {
                    return tTable[confidenceLevel][degreesOfFreedom];
                }
                
                // çº¿æ€§æ’å€¼æˆ–ä½¿ç”¨Zåˆ†æ•°è¿‘ä¼¼
                const cl = confidenceLevel;
                const df = degreesOfFreedom;
                
                // å¦‚æœè‡ªç”±åº¦å¤§äºè¡¨ä¸­æœ€å¤§å€¼ï¼Œä½¿ç”¨Zåˆ†æ•°è¿‘ä¼¼
                if (df > 99) {
                    return this.getZScore(confidenceLevel);
                }
                
                // æŸ¥æ‰¾æœ€æ¥è¿‘çš„è‡ªç”±åº¦å€¼
                let lowerDf = Math.floor(df);
                let upperDf = Math.ceil(df);
                
                if (lowerDf < 1) lowerDf = 1;
                if (upperDf > 99) upperDf = 99;
                
                if (tTable[cl] && tTable[cl][lowerDf] && tTable[cl][upperDf]) {
                    // çº¿æ€§æ’å€¼
                    const lowerT = tTable[cl][lowerDf];
                    const upperT = tTable[cl][upperDf];
                    return lowerT + (upperT - lowerT) * (df - lowerDf);
                }
                
                // é»˜è®¤ä½¿ç”¨Zåˆ†æ•°
                return this.getZScore(confidenceLevel);
            },
            
            // è¯¯å·®å‡½æ•°é€†å‡½æ•°ï¼ˆç”¨äºæ›´ç²¾ç¡®çš„Zåˆ†æ•°è®¡ç®—ï¼‰
            erfInv(x) {
                // è¿‘ä¼¼å®ç°è¯¯å·®å‡½æ•°çš„é€†å‡½æ•°
                const a = 0.14001228868666e0;
                const b = 0.44814322062058e0;
                const c = 0.96061387286725e-1;
                const d = 0.49267329197003e-1;
                const e = 0.37540566805404e-1;
                
                const y = Math.log(1 - x * x);
                const z = Math.sqrt(-y - 1.26551223 + y * (a + y * (b + y * (c + y * (d + y * e)))));
                
                return x >= 0 ? z : -z;
            },
            
            // ç»˜åˆ¶ç½®ä¿¡åŒºé—´å›¾è¡¨
            plotConfidenceIntervalChart(result) {
                try {
                    const ctx = document.getElementById('confidence-chart').getContext('2d');
                    const chartContainer = document.getElementById('confidence-chart-container');
                    
                    // æ˜¾ç¤ºå›¾è¡¨å®¹å™¨
                    chartContainer.classList.remove('hidden');
                    
                    // é”€æ¯æ—§å›¾è¡¨
                    if (this.currentChart) {
                        this.currentChart.destroy();
                    }
                    
                    // è®¡ç®—å›¾è¡¨æ•°æ®èŒƒå›´
                    const center = result.sampleMean;
                    const range = Math.max(result.marginOfError * 3, 0.01);
                    const min = center - range;
                    const max = center + range;
                    
                    // åˆ›å»ºåŸºç¡€æ•°æ®ç‚¹
                    const pointCount = 100;
                    const xLabels = [];
                    const normalData = [];
                    
                    for (let i = 0; i < pointCount; i++) {
                        const x = min + (max - min) * i / (pointCount - 1);
                        xLabels.push(x.toFixed(2));
                        
                        // è®¡ç®—æ­£æ€åˆ†å¸ƒæ¦‚ç‡å¯†åº¦
                        const std = result.testType === 'z-test' ? 
                            (result.populationStd / Math.sqrt(result.sampleSize)) : 
                            (result.sampleStd / Math.sqrt(result.sampleSize));
                        
                        const normalValue = (1 / (std * Math.sqrt(2 * Math.PI))) * 
                            Math.exp(-0.5 * Math.pow((x - center) / std, 2));
                        normalData.push(normalValue);
                    }
                    
                    // åˆ›å»ºç½®ä¿¡åŒºé—´åŒºåŸŸæ•°æ®
                    const ciRange = [];
                    const fillData = [];
                    
                    for (let i = 0; i < pointCount; i++) {
                        const x = min + (max - min) * i / (pointCount - 1);
                        ciRange.push(x);
                        
                        // ç½®ä¿¡åŒºé—´å†…çš„å€¼è®¾ä¸ºå¯¹åº”æ­£æ€åˆ†å¸ƒå€¼ï¼Œå¦åˆ™è®¾ä¸º0
                        if (x >= result.lowerBound && x <= result.upperBound) {
                            const std = result.testType === 'z-test' ? 
                                (result.populationStd / Math.sqrt(result.sampleSize)) : 
                                (result.sampleStd / Math.sqrt(result.sampleSize));
                            const normalValue = (1 / (std * Math.sqrt(2 * Math.PI))) * 
                                Math.exp(-0.5 * Math.pow((x - center) / std, 2));
                            fillData.push(normalValue);
                        } else {
                            fillData.push(0);
                        }
                    }
                    
                    // åˆ›å»ºå›¾è¡¨æ•°æ®é›†
                    const datasets = [
                        // æ­£æ€åˆ†å¸ƒæ›²çº¿
                        {
                            label: 'æŠ½æ ·åˆ†å¸ƒ',
                            data: normalData,
                            borderColor: 'rgba(74, 111, 165, 0.8)',
                            backgroundColor: 'rgba(74, 111, 165, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.4
                        },
                        // ç½®ä¿¡åŒºé—´å¡«å……
                        {
                            label: `${result.confidenceLevel * 100}% ç½®ä¿¡åŒºé—´`,
                            data: fillData,
                            backgroundColor: 'rgba(74, 111, 165, 0.3)',
                            borderColor: 'transparent',
                            fill: true,
                            tension: 0.4,
                            pointRadius: 0
                        },
                        // æ ·æœ¬å‡å€¼ç‚¹
                        {
                            label: 'æ ·æœ¬å‡å€¼',
                            data: [null, null, null, normalData[Math.floor(pointCount/2)], null, null, null],
                            backgroundColor: 'rgba(249, 160, 63, 1)',
                            borderColor: 'rgba(249, 160, 63, 1)',
                            borderWidth: 2,
                            pointRadius: 6,
                            pointHoverRadius: 8,
                            showLine: false
                        }
                    ];
                    
                    // å¦‚æœæœ‰æ€»ä½“å‡å€¼ï¼Œæ·»åŠ åˆ°å›¾è¡¨
                    if (result.populationMean !== undefined) {
                        // æ‰¾åˆ°æ€»ä½“å‡å€¼å¯¹åº”çš„ç´¢å¼•
                        let meanIndex = Math.floor(((result.populationMean - min) / (max - min)) * pointCount);
                        meanIndex = Math.max(0, Math.min(pointCount - 1, meanIndex));
                        
                        const populationMeanData = new Array(pointCount).fill(null);
                        populationMeanData[meanIndex] = normalData[meanIndex];
                        
                        datasets.push({
                            label: 'æ€»ä½“å‡å€¼',
                            data: populationMeanData,
                            backgroundColor: 'rgba(76, 175, 80, 1)',
                            borderColor: 'rgba(76, 175, 80, 1)',
                            borderWidth: 2,
                            pointRadius: 6,
                            pointHoverRadius: 8,
                            showLine: false
                        });
                    }
                    
                    // åˆ›å»ºå›¾è¡¨
                    this.currentChart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: xLabels,
                            datasets: datasets
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: {
                                    title: {
                                        display: true,
                                        text: 'å€¼'
                                    }
                                },
                                y: {
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: 'æ¦‚ç‡å¯†åº¦'
                                    }
                                }
                            },
                            plugins: {
                                title: {
                                    display: true,
                                    text: `${result.method} - ${result.confidenceLevel * 100}% ç½®ä¿¡åŒºé—´åˆ†æ`,
                                    font: {
                                        size: 16
                                    }
                                },
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            let label = context.dataset.label || '';
                                            if (label.includes('ç½®ä¿¡åŒºé—´')) {
                                                return `${label}: [${result.lowerBound.toFixed(4)}, ${result.upperBound.toFixed(4)}]`;
                                            } else if (label === 'æ ·æœ¬å‡å€¼') {
                                                return `${label}: ${result.sampleMean.toFixed(4)}`;
                                            } else if (label === 'æ€»ä½“å‡å€¼' && result.populationMean !== undefined) {
                                                return `${label}: ${result.populationMean.toFixed(4)}`;
                                            }
                                            return label;
                                        }
                                    }
                                },
                                annotation: {
                                    annotations: {
                                        lowerBoundLine: {
                                            type: 'line',
                                            xMin: result.lowerBound,
                                            xMax: result.lowerBound,
                                            borderColor: 'rgba(244, 67, 54, 0.8)',
                                            borderWidth: 2,
                                            borderDash: [5, 5],
                                            label: {
                                                content: `ä¸‹é™: ${result.lowerBound.toFixed(4)}`,
                                                enabled: true,
                                                position: 'top'
                                            }
                                        },
                                        upperBoundLine: {
                                            type: 'line',
                                            xMin: result.upperBound,
                                            xMax: result.upperBound,
                                            borderColor: 'rgba(244, 67, 54, 0.8)',
                                            borderWidth: 2,
                                            borderDash: [5, 5],
                                            label: {
                                                content: `ä¸Šé™: ${result.upperBound.toFixed(4)}`,
                                                enabled: true,
                                                position: 'top'
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    });
                } catch (error) {
                    console.error('ç»˜åˆ¶ç½®ä¿¡åŒºé—´å›¾è¡¨æ—¶å‡ºé”™:', error);
                    alert('ç»˜åˆ¶å›¾è¡¨å¤±è´¥: ' + error.message);
                }
            },
            
            // æ¸…é™¤ç½®ä¿¡åŒºé—´ç»“æœ
            clearConfidenceResults() {
                try {
                    // é”€æ¯å›¾è¡¨
                    if (this.currentChart) {
                        this.currentChart.destroy();
                        this.currentChart = null;
                    }
                    
                    // éšè—ç»“æœå®¹å™¨
                    document.getElementById('confidence-results').classList.add('hidden');
                    document.getElementById('confidence-interpretation').classList.add('hidden');
                    document.getElementById('sample-size-result').classList.add('hidden');
                    document.getElementById('sample-size-calculator').classList.add('hidden');
                } catch (error) {
                    console.error('æ¸…é™¤ç½®ä¿¡åŒºé—´ç»“æœæ—¶å‡ºé”™:', error);
                }
            },
            
            // ç”Ÿæˆç½®ä¿¡åŒºé—´æ ·æœ¬æ•°æ®ï¼ˆä»…ç”¨äºç½®ä¿¡åŒºé—´åˆ†æï¼‰
            generateConfidenceSampleData(distributionType, sampleSize, mean, std) {
                const data = [];
                
                for (let i = 0; i < sampleSize; i++) {
                    if (distributionType === 'normal') {
                        // ä½¿ç”¨Box-Mullerå˜æ¢ç”Ÿæˆæ­£æ€åˆ†å¸ƒéšæœºæ•°
                        let u1, u2;
                        do {
                            u1 = Math.random();
                            u2 = Math.random();
                        } while (u1 <= Number.EPSILON);
                        
                        const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                        data.push(mean + z0 * std);
                    } else if (distributionType === 'uniform') {
                        // ç”Ÿæˆå‡åŒ€åˆ†å¸ƒéšæœºæ•°
                        // å‡åŒ€åˆ†å¸ƒçš„æ ‡å‡†å·® = (max - min) / Math.sqrt(12)
                        // å› æ­¤ max = mean + std * Math.sqrt(12) / 2
                        //     min = mean - std * Math.sqrt(12) / 2
                        const range = std * Math.sqrt(12);
                        const min = mean - range / 2;
                        const max = mean + range / 2;
                        data.push(min + Math.random() * (max - min));
                    }
                }
                
                return data;
            },
            
            // æ•°æ®åˆ†æ
            analyzeData() {
                try {
                    const inputMethod = document.querySelector('input[name="data-input-method"]:checked').value;
                    
                    if (inputMethod === 'distribution') {
                        // ä½¿ç”¨åˆ†å¸ƒç”Ÿæˆçš„æ•°æ®
                        if (!this.generatedData) {
                            alert('è¯·å…ˆåœ¨åˆ†å¸ƒæ¨¡æ‹Ÿæ ‡ç­¾é¡µä¸­ç”Ÿæˆæ•°æ®');
                            return;
                        }
                        
                        this.updateChart();
                        // æ‰§è¡Œå‚æ•°ä¼°è®¡
                        this.estimateParameters();
                    } else if (inputMethod === 'file') {
                        // ä½¿ç”¨ä¸Šä¼ çš„æ–‡ä»¶æ•°æ®
                        // æ–‡ä»¶ä¸Šä¼ å¤„ç†é€»è¾‘å°†åœ¨handleFileUploadä¸­è®¾ç½®this.generatedData
                        if (!this.generatedData) {
                            alert('è¯·å…ˆä¸Šä¼ CSVæ–‡ä»¶');
                            return;
                        }
                        
                        this.updateChart();
                        // æ‰§è¡Œå‚æ•°ä¼°è®¡
                        this.estimateParameters();
                    } else if (inputMethod === 'ai') {
                        // ä½¿ç”¨AIç”Ÿæˆçš„æ•°æ®
                        if (!this.generatedData) {
                            alert('è¯·å…ˆç”ŸæˆAIæ•°æ®');
                            return;
                        }
                        
                        this.updateChart();
                        // æ‰§è¡Œå‚æ•°ä¼°è®¡
                        this.estimateParameters();
                    }
                } catch (error) {
                    console.error('åˆ†ææ•°æ®æ—¶å‡ºé”™:', error);
                    alert('åˆ†ææ•°æ®å¤±è´¥ï¼Œè¯·é‡è¯•');
                }
            },
            
            // æ›´æ–°å›¾è¡¨
            updateChart() {
                try {
                    const chartType = document.getElementById('chart-type').value;
                    const ctx = document.getElementById('analysis-chart').getContext('2d');
                    const chartContainer = document.getElementById('analysis-chart-container');
                    
                    // æ˜¾ç¤ºå›¾è¡¨å®¹å™¨
                    if (chartContainer) {
                        chartContainer.classList.remove('hidden');
                    }
                    
                    // é”€æ¯æ—§å›¾è¡¨
                    if (this.currentChart) {
                        this.currentChart.destroy();
                    }
                    
                    const data = this.generatedData;
                    let chartConfig;
                    
                    switch (chartType) {
                        case 'histogram':
                            chartConfig = this.createHistogramConfig(data);
                            break;
                        case 'bar':
                            chartConfig = this.createHistogramConfig(data);
                            break;
                        case 'scatter':
                            chartConfig = this.createScatterConfig(data);
                            break;
                        case 'line':
                            chartConfig = this.createLineConfig(data);
                            break;
                        default:
                            chartConfig = this.createHistogramConfig(data);
                    }
                    
                    // åˆ›å»ºå›¾è¡¨
                    this.currentChart = new Chart(ctx, chartConfig);
                } catch (error) {
                    console.error('æ›´æ–°å›¾è¡¨æ—¶å‡ºé”™:', error);
                    alert('æ›´æ–°å›¾è¡¨å¤±è´¥ï¼Œè¯·é‡è¯•');
                }
            },
            
            // åˆ›å»ºç›´æ–¹å›¾é…ç½®
            createHistogramConfig(data) {
                // è®¡ç®—ç›´æ–¹å›¾æ•°æ®
                const binCount = Math.min(Math.ceil(Math.sqrt(data.length)), 50);
                const min = Math.min(...data);
                const max = Math.max(...data);
                const binWidth = (max - min) / binCount;
                
                const bins = Array(binCount).fill(0);
                const binLabels = [];
                
                for (let i = 0; i < binCount; i++) {
                    binLabels.push((min + i * binWidth).toFixed(2));
                }
                
                data.forEach(value => {
                    if (value >= min && value <= max) {
                        const binIndex = Math.min(Math.floor((value - min) / binWidth), binCount - 1);
                        bins[binIndex]++;
                    }
                });
                
                // å½’ä¸€åŒ–é¢‘ç‡
                const frequencies = bins.map(count => count / data.length);
                
                return {
                    type: 'bar',
                    data: {
                        labels: binLabels,
                        datasets: [{
                            label: 'é¢‘ç‡',
                            data: frequencies,
                            backgroundColor: 'rgba(74, 111, 165, 0.7)',
                            borderColor: 'rgba(74, 111, 165, 1)',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'å€¼'
                                },
                                ticks: {
                                    autoSkip: true,
                                    maxRotation: 0,
                                    callback: function(value, index, values) {
                                        // åªæ˜¾ç¤ºéƒ¨åˆ†æ ‡ç­¾ä»¥é¿å…æ‹¥æŒ¤
                                        return index % Math.ceil(binCount / 20) === 0 ? this.getLabelForValue(value) : '';
                                    }
                                }
                            },
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'é¢‘ç‡'
                                },
                                ticks: {
                                    callback: function(value) {
                                        return value.toFixed(3);
                                    }
                                }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `ç›´æ–¹å›¾åˆ†æ (æ ·æœ¬å¤§å°: ${data.length})`,
                                font: {
                                    size: 16
                                }
                            }
                        }
                    }
                };
            },
            
            // åˆ›å»ºæ•£ç‚¹å›¾é…ç½®
            createScatterConfig(data) {
                // å‡†å¤‡æ•£ç‚¹å›¾æ•°æ®
                const scatterData = data.slice(0, 1000).map((value, index) => ({
                    x: index,
                    y: value
                }));
                
                return {
                    type: 'scatter',
                    data: {
                        datasets: [{
                            label: 'æ•°æ®ç‚¹',
                            data: scatterData,
                            backgroundColor: 'rgba(74, 111, 165, 0.7)',
                            pointRadius: 3,
                            pointHoverRadius: 5
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'ç´¢å¼•'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'å€¼'
                                }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `æ•£ç‚¹å›¾åˆ†æ (æ˜¾ç¤ºå‰1000ä¸ªç‚¹)`,
                                font: {
                                    size: 16
                                }
                            }
                        }
                    }
                };
            },
            
            // åˆ›å»ºæŠ˜çº¿å›¾é…ç½®
            createLineConfig(data) {
                // å‡†å¤‡æŠ˜çº¿å›¾æ•°æ®ï¼ˆå–å‰1000ä¸ªç‚¹ä»¥é¿å…å›¾è¡¨è¿‡äºå¯†é›†ï¼‰
                const displayData = data.slice(0, 1000);
                const indices = Array.from({ length: displayData.length }, (_, i) => i);
                
                return {
                    type: 'line',
                    data: {
                        labels: indices,
                        datasets: [{
                            label: 'æ•°æ®è¶‹åŠ¿',
                            data: displayData,
                            backgroundColor: 'rgba(74, 111, 165, 0.1)',
                            borderColor: 'rgba(74, 111, 165, 1)',
                            borderWidth: 1,
                            fill: true,
                            tension: 0.1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'ç´¢å¼•'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'å€¼'
                                }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `æŠ˜çº¿å›¾åˆ†æ (æ˜¾ç¤ºå‰1000ä¸ªç‚¹)`,
                                font: {
                                    size: 16
                                }
                            }
                        }
                    }
                };
            },
            
            // å¤„ç†æ–‡ä»¶ä¸Šä¼ 
            handleFileUpload(event) {
                try {
                    const file = event.target.files[0];
                    if (!file) {
                        return;
                    }
                    
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const content = e.target.result;
                            const data = this.parseCSVData(content);
                            
                            if (data.length === 0) {
                                alert('æœªèƒ½ä»æ–‡ä»¶ä¸­è§£æå‡ºæ•°æ®');
                                return;
                            }
                            
                            this.generatedData = data;
                            alert(`æˆåŠŸå¯¼å…¥ ${data.length} ä¸ªæ•°æ®ç‚¹`);
                        } catch (error) {
                            console.error('è§£ææ–‡ä»¶æ—¶å‡ºé”™:', error);
                            alert('è§£ææ–‡ä»¶å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼');
                        }
                    };
                    
                    reader.onerror = () => {
                        alert('è¯»å–æ–‡ä»¶å¤±è´¥');
                    };
                    
                    reader.readAsText(file);
                } catch (error) {
                    console.error('å¤„ç†æ–‡ä»¶ä¸Šä¼ æ—¶å‡ºé”™:', error);
                    alert('ä¸Šä¼ æ–‡ä»¶å¤±è´¥ï¼Œè¯·é‡è¯•');
                }
            },
            
            // è§£æCSVæ•°æ®
            parseCSVData(content) {
                // å°è¯•ä¸åŒçš„CSVæ ¼å¼è§£æ
                const lines = content.split(/[\r\n]+/).filter(line => line.trim() !== '');
                const data = [];
                
                // å°è¯•æ¯è¡Œä¸€ä¸ªæ•°æ®
                if (lines.length > 0 && lines[0].indexOf(',') === -1) {
                    for (const line of lines) {
                        const value = parseFloat(line.trim());
                        if (!isNaN(value)) {
                            data.push(value);
                        }
                    }
                } else {
                    // å°è¯•é€—å·åˆ†éš”çš„æ•°æ®
                    for (const line of lines) {
                        const values = line.split(',').map(val => parseFloat(val.trim()));
                        for (const value of values) {
                            if (!isNaN(value)) {
                                data.push(value);
                            }
                        }
                    }
                }
                
                return data;
            },
            
            // åˆ‡æ¢æ•°æ®è¾“å…¥æ–¹å¼
            switchDataInputMethod() {
                try {
                    const inputMethod = document.querySelector('input[name="data-input-method"]:checked').value;
                    const fileInputContainer = document.getElementById('file-data-input');
                    const aiInputContainer = document.getElementById('ai-data-input');
                    
                    // å¤„ç†æ–‡ä»¶è¾“å…¥å®¹å™¨
                    if (fileInputContainer) {
                        if (inputMethod === 'file') {
                            fileInputContainer.classList.remove('hidden');
                        } else {
                            fileInputContainer.classList.add('hidden');
                            // æ¸…é™¤æ–‡ä»¶è¾“å…¥
                            const fileInput = document.getElementById('file-upload');
                            if (fileInput) {
                                fileInput.value = '';
                            }
                        }
                    }
                    
                    // å¤„ç†AIè¾“å…¥å®¹å™¨
                    if (aiInputContainer) {
                        if (inputMethod === 'ai') {
                            aiInputContainer.classList.remove('hidden');
                        } else {
                            aiInputContainer.classList.add('hidden');
                        }
                    }
                } catch (error) {
                    console.error('åˆ‡æ¢æ•°æ®è¾“å…¥æ–¹å¼æ—¶å‡ºé”™:', error);
                }
            },
            
            // AIç”Ÿæˆæ•°æ®
            generateAIData() {
                console.log('å¼€å§‹AIç”Ÿæˆæ•°æ®...');
                try {
                    const description = document.getElementById('ai-data-description').value;
                    const count = parseInt(document.getElementById('ai-data-count').value);
                    const seed = document.getElementById('ai-data-seed').value ? parseInt(document.getElementById('ai-data-seed').value) : null;
                    
                    // éªŒè¯è¾“å…¥
                    if (!description.trim()) {
                        alert('è¯·è¾“å…¥æ•°æ®æè¿°');
                        return;
                    }
                    
                    if (isNaN(count) || count < 100 || count > 10000) {
                        alert('è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°æ®ç‚¹æ•°é‡ï¼ˆ100-10000ï¼‰');
                        return;
                    }
                    
                    // æ˜¾ç¤ºè¿›åº¦æ¡
                    const progressContainer = document.getElementById('generation-progress');
                    const progressFill = progressContainer ? progressContainer.querySelector('.progress-fill') : null;
                    const progressText = progressContainer ? progressContainer.querySelector('.progress-text') : null;
                    
                    if (progressContainer && progressFill && progressText) {
                        progressContainer.classList.remove('hidden');
                        progressFill.style.width = '0%';
                        progressText.textContent = 'AIæ­£åœ¨ç”Ÿæˆæ•°æ®...';
                    }
                    
                    // æ¨¡æ‹Ÿç”Ÿæˆè¿‡ç¨‹ä¸­çš„è¿›åº¦æ›´æ–°
                    let progress = 0;
                    const interval = setInterval(() => {
                        progress += 5;
                        if (progressFill && progressText) {
                            progressFill.style.width = `${Math.min(progress, 90)}%`;
                            progressText.textContent = `AIæ­£åœ¨ç”Ÿæˆæ•°æ®... ${progress}%`;
                        }
                        
                        if (progress >= 100) {
                            clearInterval(interval);
                        }
                    }, 50);
                    
                    // å®šä¹‰æ¸…ç†å‡½æ•°
                    const cleanup = () => {
                        clearInterval(interval);
                        if (progressContainer) {
                            progressContainer.classList.add('hidden');
                        }
                    };
                    
                    // å°è¯•ä½¿ç”¨çœŸå®çš„AI API
                    if (this.ai && this.ai.isConfigured) {
                        console.log('ä½¿ç”¨çœŸå®AI APIç”Ÿæˆæ•°æ®');
                        
                        // æ„å»ºæç¤ºè¯
                        const prompt = `æ ¹æ®ä»¥ä¸‹æè¿°ç”Ÿæˆ${count}ä¸ªæ•°å€¼æ•°æ®ç‚¹ï¼š\n${description}\n\nè¯·ç”Ÿæˆä¸€ä¸ªåŒ…å«${count}ä¸ªæ•°å€¼çš„æ•°ç»„ï¼Œæ¯ä¸ªæ•°å€¼å•ç‹¬ä¸€è¡Œã€‚ä¸è¦åŒ…å«ä»»ä½•é¢å¤–çš„æ–‡å­—ã€è§£é‡Šæˆ–æ ¼å¼ï¼Œåªéœ€è¦çº¯æ•°å€¼æ•°æ®ã€‚`;
                        
                        // è°ƒç”¨AI API
                        this.generateWithRealAI(prompt, count, progressFill, progressText, cleanup);
                    } else {
                        console.log('ä½¿ç”¨æ¨¡æ‹ŸAIç”Ÿæˆæ•°æ®ï¼ˆæœªé…ç½®çœŸå®AI APIï¼‰');
                        
                        // å¦‚æœæ²¡æœ‰é…ç½®çœŸå®AIï¼Œæ˜¾ç¤ºæç¤º
                        if (!this.ai) {
                            console.warn('AIé›†æˆæœªåˆå§‹åŒ–');
                        } else {
                            console.warn('æœªé…ç½®AI APIå¯†é’¥ï¼Œç‚¹å‡»"AIè®¾ç½®"æŒ‰é’®è¿›è¡Œé…ç½®');
                        }
                        
                        // ç»§ç»­ä½¿ç”¨æ¨¡æ‹ŸAIç”Ÿæˆæ•°æ®
                        setTimeout(() => {
                            try {
                                // æ ¹æ®æè¿°å’Œéšæœºç§å­ç”Ÿæˆæ•°æ®
                                let data = this.simulateAIDataGeneration(description, count, seed);
                                
                                // ç¡®ä¿æ•°æ®ç”ŸæˆæˆåŠŸ
                                if (!data || data.length === 0) {
                                    throw new Error('AIæ•°æ®ç”Ÿæˆå¤±è´¥ï¼Œè¿”å›ç©ºæ•°æ®');
                                }
                                
                                console.log('æ¨¡æ‹ŸAIæ•°æ®ç”ŸæˆæˆåŠŸï¼Œé•¿åº¦:', data.length);
                                this.generatedData = data;
                                
                                // æ›´æ–°è¿›åº¦æ¡ä¸º100%
                                if (progressFill && progressText) {
                                    progressFill.style.width = '100%';
                                    progressText.textContent = 'AIæ•°æ®ç”Ÿæˆå®Œæˆï¼';
                                }
                                
                                alert(`æ¨¡æ‹ŸAIæ•°æ®ç”ŸæˆæˆåŠŸï¼å·²ç”Ÿæˆ ${data.length} ä¸ªæ•°æ®ç‚¹\n\næç¤ºï¼šé…ç½®çœŸå®AI APIå¯è·å¾—æ›´å‡†ç¡®çš„æ•°æ®ç”Ÿæˆç»“æœã€‚ç‚¹å‡»"AIè®¾ç½®"æŒ‰é’®è¿›è¡Œé…ç½®ã€‚`);
                                
                                // éšè—è¿›åº¦æ¡
                                setTimeout(() => {
                                    cleanup();
                                }, 500);
                            } catch (error) {
                                console.error('æ¨¡æ‹ŸAIç”Ÿæˆæ•°æ®æ—¶å‡ºé”™:', error);
                                alert('AIæ•°æ®ç”Ÿæˆæ—¶å‡ºé”™: ' + error.message);
                                cleanup();
                            }
                        }, 1500);
                    }
                } catch (error) {
                    console.error('è°ƒç”¨AIç”Ÿæˆæ•°æ®å‡½æ•°æ—¶å‡ºé”™:', error);
                    alert('AIç”Ÿæˆæ•°æ®å¤±è´¥: ' + error.message);
                }
            },
            
            // ä½¿ç”¨çœŸå®AI APIç”Ÿæˆæ•°æ®
            async generateWithRealAI(prompt, count, progressFill, progressText, cleanup) {
                try {
                    // æ›´æ–°è¿›åº¦æ–‡æœ¬
                    if (progressText) {
                        progressText.textContent = 'æ­£åœ¨è°ƒç”¨AI API...';
                    }
                    
                    // è°ƒç”¨DashScope API
                    const response = await fetch(`${this.ai.baseUrl}/services/aigc/text-generation/generation`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.ai.apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: this.ai.model,
                            input: {
                                messages: [
                                    { role: 'user', content: prompt }
                                ]
                            }
                        })
                    });
                    
                    // æ›´æ–°è¿›åº¦
                    if (progressFill && progressText) {
                        progressFill.style.width = '70%';
                        progressText.textContent = 'æ­£åœ¨è§£æAIå“åº”...';
                    }
                    
                    if (response.ok) {
                        const result = await response.json();
                        const aiText = result.output.text;
                        
                        // è§£æAIç”Ÿæˆçš„æ•°å€¼æ•°æ®
                        const lines = aiText.trim().split('\n');
                        const data = [];
                        
                        for (const line of lines) {
                            const trimmedLine = line.trim();
                            if (trimmedLine) {
                                const num = parseFloat(trimmedLine);
                                if (!isNaN(num)) {
                                    data.push(num);
                                }
                            }
                        }
                        
                        // å¦‚æœAIç”Ÿæˆçš„æ•°æ®ä¸è¶³ï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®è¡¥å……
                        if (data.length < count * 0.5) {
                            console.warn(`AIåªç”Ÿæˆäº†${data.length}ä¸ªæ•°æ®ç‚¹ï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®è¡¥å……`);
                            const simulatedData = this.simulateAIDataGeneration(prompt, count - data.length, null);
                            data.push(...simulatedData);
                        } else if (data.length > count) {
                            // å¦‚æœç”Ÿæˆçš„æ•°æ®è¿‡å¤šï¼Œæˆªå–å‰countä¸ª
                            data.length = count;
                        }
                        
                        console.log('çœŸå®AIæ•°æ®ç”ŸæˆæˆåŠŸï¼Œé•¿åº¦:', data.length);
                        this.generatedData = data;
                        
                        // æ›´æ–°è¿›åº¦æ¡ä¸º100%
                        if (progressFill && progressText) {
                            progressFill.style.width = '100%';
                            progressText.textContent = 'AIæ•°æ®ç”Ÿæˆå®Œæˆï¼';
                        }
                        
                        alert(`çœŸå®AIæ•°æ®ç”ŸæˆæˆåŠŸï¼å·²ç”Ÿæˆ ${data.length} ä¸ªæ•°æ®ç‚¹`);
                        
                        // éšè—è¿›åº¦æ¡
                        setTimeout(() => {
                            cleanup();
                        }, 500);
                    } else {
                        const errorText = await response.text();
                        throw new Error(`APIè°ƒç”¨å¤±è´¥: ${response.status} - ${errorText}`);
                    }
                } catch (error) {
                    console.error('çœŸå®AIç”Ÿæˆæ•°æ®æ—¶å‡ºé”™:', error);
                    alert(`çœŸå®AIç”Ÿæˆæ•°æ®å¤±è´¥: ${error.message}\n\nå°†å›é€€åˆ°æ¨¡æ‹ŸAIç”Ÿæˆ...`);
                    
                    // å›é€€åˆ°æ¨¡æ‹ŸAI
                    try {
                        const data = this.simulateAIDataGeneration(prompt, count, null);
                        if (data && data.length > 0) {
                            this.generatedData = data;
                            console.log('å›é€€åˆ°æ¨¡æ‹ŸAIæˆåŠŸï¼Œé•¿åº¦:', data.length);
                        }
                    } catch (e) {
                        console.error('å›é€€åˆ°æ¨¡æ‹ŸAIä¹Ÿå¤±è´¥:', e);
                    } finally {
                        cleanup();
                    }
                }
            },
            
            // æ¨¡æ‹ŸAIæ•°æ®ç”Ÿæˆï¼ˆåŸºäºæè¿°å’Œç§å­ï¼‰
            simulateAIDataGeneration(description, count, seed) {
                console.log('æ¨¡æ‹ŸAIæ•°æ®ç”Ÿæˆï¼Œæè¿°:', description, 'æ•°é‡:', count, 'ç§å­:', seed);
                
                // è®¾ç½®éšæœºç§å­
                if (seed !== null) {
                    Math.seedrandom = function(seed) {
                        var s = seed + '';
                        Math.sin(s.charCodeAt(0))
                    };
                    Math.seedrandom(seed);
                }
                
                // æ ¹æ®æè¿°åˆ†ææ•°æ®æ¨¡å¼
                let data = [];
                const hasTrend = description.toLowerCase().includes('è¶‹åŠ¿') || description.toLowerCase().includes('trend');
                const hasVolatility = description.toLowerCase().includes('æ³¢åŠ¨') || description.toLowerCase().includes('volatility');
                const hasSeasonality = description.toLowerCase().includes('å­£èŠ‚æ€§') || description.toLowerCase().includes('seasonal');
                const isStockLike = description.toLowerCase().includes('è‚¡ç¥¨') || description.toLowerCase().includes('stock') || description.toLowerCase().includes('price');
                const isNormal = description.toLowerCase().includes('æ­£æ€') || description.toLowerCase().includes('normal');
                const isUniform = description.toLowerCase().includes('å‡åŒ€') || description.toLowerCase().includes('uniform');
                
                // æ ¹æ®ä¸åŒç‰¹å¾ç”Ÿæˆæ•°æ®
                if (isNormal) {
                    // æ­£æ€åˆ†å¸ƒæ•°æ®
                    const mean = 50 + Math.random() * 50;
                    const stdDev = 10 + Math.random() * 20;
                    for (let i = 0; i < count; i++) {
                        data.push(this.normalRandom(mean, stdDev));
                    }
                } else if (isUniform) {
                    // å‡åŒ€åˆ†å¸ƒæ•°æ®
                    const min = Math.random() * 100;
                    const max = min + 100 + Math.random() * 100;
                    for (let i = 0; i < count; i++) {
                        data.push(min + Math.random() * (max - min));
                    }
                } else if (isStockLike || hasTrend) {
                    // è‚¡ç¥¨ä»·æ ¼ç±»æ•°æ®ï¼ˆå¸¦è¶‹åŠ¿ï¼‰
                    let price = 100 + Math.random() * 100;
                    const trend = (Math.random() - 0.45) * 2; // è½»å¾®æ­£è¶‹åŠ¿
                    const volatility = hasVolatility ? (0.01 + Math.random() * 0.02) : 0.01;
                    
                    for (let i = 0; i < count; i++) {
                        // æ·»åŠ å­£èŠ‚æ€§å½±å“
                        const seasonal = hasSeasonality ? Math.sin(i / 20) * 5 : 0;
                        // æ·»åŠ éšæœºæ³¢åŠ¨
                        const randomChange = (Math.random() - 0.5) * 2 * volatility * price;
                        // æ›´æ–°ä»·æ ¼
                        price = price * (1 + trend / 100) + randomChange + seasonal;
                        // ç¡®ä¿ä»·æ ¼ä¸ºæ­£
                        price = Math.max(price, 0.1);
                        data.push(price);
                    }
                } else {
                    // é»˜è®¤æ··åˆåˆ†å¸ƒæ•°æ®
                    for (let i = 0; i < count; i++) {
                        // æ ¹æ®æè¿°ä¸­å¯èƒ½åŒ…å«çš„å…³é”®è¯è°ƒæ•´ç”Ÿæˆé€»è¾‘
                        if (description.toLowerCase().includes('å¢é•¿') || description.toLowerCase().includes('increase')) {
                            // å¢é•¿è¶‹åŠ¿æ•°æ®
                            data.push(100 + i * (0.5 + Math.random() * 0.5) + (Math.random() - 0.5) * 20);
                        } else if (description.toLowerCase().includes('å‘¨æœŸ') || description.toLowerCase().includes('cycle')) {
                            // å‘¨æœŸæ€§æ•°æ®
                            data.push(100 + Math.sin(i / 10) * 50 + (Math.random() - 0.5) * 20);
                        } else {
                            // é»˜è®¤æ­£æ€åˆ†å¸ƒå¸¦ä¸€äº›å˜åŒ–
                            data.push(100 + (Math.random() - 0.5) * 100);
                        }
                    }
                }
                
                return data;
            },
            
            // æ­£æ€åˆ†å¸ƒéšæœºæ•°ç”Ÿæˆ
            normalRandom(mean, stdDev) {
                let u = 0, v = 0;
                while(u === 0) u = Math.random();
                while(v === 0) v = Math.random();
                let z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
                return mean + z * stdDev;
            },
            
            // é‡ç½®åˆ†æ
            resetAnalysis() {
                try {
                    // é”€æ¯å›¾è¡¨
                    if (this.currentChart) {
                        this.currentChart.destroy();
                        this.currentChart = null;
                    }
                    
                    // éšè—å›¾è¡¨å®¹å™¨
                    const chartContainer = document.getElementById('analysis-chart-container');
                    if (chartContainer) {
                        chartContainer.classList.add('hidden');
                    }
                    
                    // é‡ç½®æ–‡ä»¶è¾“å…¥
                    const fileInput = document.getElementById('file-upload');
                    if (fileInput) {
                        fileInput.value = '';
                    }
                    
                    // é‡ç½®AIæ•°æ®è¾“å…¥
                    const aiDescription = document.getElementById('ai-data-description');
                    const aiDataCount = document.getElementById('ai-data-count');
                    const aiDataSeed = document.getElementById('ai-data-seed');
                    
                    if (aiDescription) {
                        aiDescription.value = '';
                    }
                    
                    if (aiDataCount) {
                        aiDataCount.value = '1000';
                    }
                    
                    if (aiDataSeed) {
                        aiDataSeed.value = '';
                    }
                    
                    // åˆ‡æ¢å›åˆ†å¸ƒè¾“å…¥æ–¹å¼
                    const distributionRadio = document.querySelector('input[name="data-input-method"][value="distribution"]');
                    if (distributionRadio) {
                        distributionRadio.checked = true;
                        this.switchDataInputMethod();
                    }
                } catch (error) {
                    console.error('é‡ç½®åˆ†ææ—¶å‡ºé”™:', error);
                }
            },
            
            // è·å–åˆ†å¸ƒåç§°
            getDistributionName(type) {
                const names = {
                    'normal': 'æ­£æ€',
                    'binomial': 'äºŒé¡¹',
                    'poisson': 'æ³Šæ¾',
                    'uniform': 'å‡åŒ€',
                    'exponential': 'æŒ‡æ•°'
                };
                
                return names[type] || type;
            },
            
            // åŠŸæ•ˆå‡½æ•°å›¾è¡¨å®ä¾‹
            powerChart: null,
            
            // åŠŸæ•ˆå‡½æ•°è®¡ç®—ç›¸å…³æ–¹æ³•
            initPowerAnalysis() {
                // ç¡®ä¿Math.erfå‡½æ•°å¯ç”¨
                if (typeof Math.erf === 'undefined') {
                    // å®ç°è¯¯å·®å‡½æ•°
                    Math.erf = function(x) {
                        // è¯¯å·®å‡½æ•°çš„è¿‘ä¼¼å®ç°
                        const a1 = 0.254829592;
                        const a2 = -0.284496736;
                        const a3 = 1.421413741;
                        const a4 = -1.453152027;
                        const a5 = 1.061405429;
                        const p = 0.3275911;
                        
                        const sign = (x >= 0) ? 1 : -1;
                        x = Math.abs(x);
                        
                        const t = 1.0 / (1.0 + p * x);
                        const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
                        
                        return sign * y;
                    };
                }
                
                // è®¾ç½®æ£€éªŒç±»å‹å˜åŒ–äº‹ä»¶ç›‘å¬å™¨
                document.getElementById('power-analysis-type').addEventListener('change', () => {
                    this.updatePowerAnalysisUI();
                });
                
                // è®¾ç½®è®¡ç®—æŒ‰é’®äº‹ä»¶ç›‘å¬å™¨
                document.getElementById('calculate-power').addEventListener('click', () => {
                    this.calculateSampleSize();
                });
                
                // è®¾ç½®æ¸…é™¤æŒ‰é’®äº‹ä»¶ç›‘å¬å™¨
                document.getElementById('clear-power-results').addEventListener('click', () => {
                    this.clearPowerResults();
                });
                
                // è®¾ç½®æ˜¾ç¤ºå…¬å¼å¤é€‰æ¡†äº‹ä»¶ç›‘å¬å™¨
                document.getElementById('show-formula').addEventListener('change', (e) => {
                    const formulaContainer = document.getElementById('formula-container');
                    if (e.target.checked) {
                        formulaContainer.classList.remove('hidden');
                    } else {
                        formulaContainer.classList.add('hidden');
                    }
                });
                
                // è®¾ç½®æ˜¾ç¤ºå›¾è¡¨å¤é€‰æ¡†äº‹ä»¶ç›‘å¬å™¨
                document.getElementById('show-power-chart').addEventListener('change', (e) => {
                    const chartContainer = document.getElementById('power-chart-container');
                    if (e.target.checked) {
                        chartContainer.classList.remove('hidden');
                        // å¦‚æœå·²ç»æœ‰è®¡ç®—ç»“æœï¼Œåˆ™æ›´æ–°å›¾è¡¨
                        if (!document.getElementById('power-results').classList.contains('hidden')) {
                            this.updatePowerChart();
                        }
                    } else {
                        chartContainer.classList.add('hidden');
                    }
                });
                
                // åˆå§‹åŒ–UIçŠ¶æ€
                this.updatePowerAnalysisUI();
            },
            
            // æ ¹æ®æ£€éªŒç±»å‹æ›´æ–°UI
            updatePowerAnalysisUI() {
                const testType = document.getElementById('power-analysis-type').value;
                const stdInput = document.getElementById('std-input');
                const proportionParams = document.getElementById('proportion-params');
                
                if (testType === 'proportion') {
                    stdInput.classList.add('hidden');
                    proportionParams.classList.remove('hidden');
                } else {
                    stdInput.classList.remove('hidden');
                    proportionParams.classList.add('hidden');
                }
            },
            
            // è·å–Zåˆ†æ•°ï¼ˆé€†æ ‡å‡†æ­£æ€åˆ†å¸ƒï¼‰
            getZScore(alpha) {
                // é€†æ­£æ€åˆ†å¸ƒçš„è¿‘ä¼¼è®¡ç®—
                const sign = alpha > 0.5 ? -1 : 1;
                const x = Math.abs(2 * alpha - 1);
                
                const a = [0.196854, 0.115194, 0.000344, 0.019527];
                const b = [0.231772, 0.12704, 0.001442, 0.01228];
                
                let y = Math.log(1 - x * x);
                let p = a[0] + y * (a[1] + y * (a[2] + y * a[3]));
                let q = b[0] + y * (b[1] + y * (b[2] + y * b[3]));
                
                let z = sign * Math.sqrt(-2 * y * p / q);
                
                // äºŒæ¬¡è¿­ä»£ä»¥æé«˜ç²¾åº¦
                const z2 = this.getZScoreFromErfInv(alpha);
                
                return z2;
            },
            
            // ä½¿ç”¨è¯¯å·®å‡½æ•°çš„é€†å‡½æ•°è®¡ç®—Zåˆ†æ•°
            getZScoreFromErfInv(alpha) {
                // å¯¹äºæ ‡å‡†æ­£æ€åˆ†å¸ƒï¼Œç´¯ç§¯åˆ†å¸ƒå‡½æ•°å’Œè¯¯å·®å‡½æ•°çš„å…³ç³»ä¸ºï¼š
                // Î¦(x) = (1 + erf(x/âˆš2))/2
                // å› æ­¤ï¼Œå¯¹äºç»™å®šçš„Î±ï¼Œæˆ‘ä»¬éœ€è¦æ±‚è§£ Î¦^{-1}(Î±)
                
                const sign = alpha > 0.5 ? -1 : 1;
                const target = alpha > 0.5 ? 1 - alpha : alpha;
                
                // è®¡ç®—é€†è¯¯å·®å‡½æ•°å€¼
                const erfInvValue = this.erfInv(2 * target - 1);
                
                // è½¬æ¢ä¸ºZåˆ†æ•°
                const z = sign * Math.sqrt(2) * erfInvValue;
                
                return z;
            },
            
            // è¯¯å·®å‡½æ•°çš„é€†å‡½æ•°
            erfInv(x) {
                // é€†è¯¯å·®å‡½æ•°çš„è¿‘ä¼¼å®ç°
                const a = 0.147;
                const sgn = x < 0 ? -1 : 1;
                const x_abs = Math.abs(x);
                
                if (x_abs >= 1) {
                    return sgn * Infinity;
                }
                
                const log_1_minus_x_sq = Math.log(1 - x_abs * x_abs);
                const t = Math.sqrt(-log_1_minus_x_sq + a * log_1_minus_x_sq * x_abs * x_abs);
                
                return sgn * t;
            },
            
            // è®¡ç®—æ‰€éœ€æ ·æœ¬é‡
            calculateSampleSize() {
                const testType = document.getElementById('power-analysis-type').value;
                const alpha = parseFloat(document.getElementById('alpha-value').value);
                const power = parseFloat(document.getElementById('power-value').value);
                const effectSize = parseFloat(document.getElementById('effect-size').value);
                const testDirection = document.getElementById('power-test-direction').value;
                
                let requiredSampleSize = 0;
                let formula = '';
                
                // è®¡ç®—betaå€¼
                const beta = 1 - power;
                
                // æ ¹æ®æ£€éªŒç±»å‹è®¡ç®—æ ·æœ¬é‡
                switch (testType) {
                    case 'one-sample-mean':
                        requiredSampleSize = this.calculateOneSampleMeanSampleSize(alpha, beta, effectSize, testDirection);
                        formula = this.getOneSampleMeanFormula(testDirection);
                        break;
                    case 'two-sample-mean':
                        requiredSampleSize = this.calculateTwoSampleMeanSampleSize(alpha, beta, effectSize, testDirection);
                        formula = this.getTwoSampleMeanFormula(testDirection);
                        break;
                    case 'proportion':
                        requiredSampleSize = this.calculateProportionSampleSize(alpha, beta, testDirection);
                        formula = this.getProportionFormula();
                        break;
                }
                
                // æ˜¾ç¤ºç»“æœ
                this.displayPowerResults(requiredSampleSize, alpha, power, effectSize, testType, testDirection, formula);
                
                // è®¡ç®—å®Œæˆåæ›´æ–°å›¾è¡¨
                this.updatePowerChart();
            },
            
            // è®¡ç®—å•æ ·æœ¬å‡å€¼æ£€éªŒçš„æ ·æœ¬é‡
            calculateOneSampleMeanSampleSize(alpha, beta, delta, testDirection) {
                const sigma = parseFloat(document.getElementById('std-deviation').value);
                
                // æ ¹æ®æ£€éªŒæ–¹å‘è°ƒæ•´alphaå€¼
                const alphaAdjusted = testDirection === 'two-tailed' ? alpha / 2 : alpha;
                
                // è·å–Zåˆ†æ•°
                const zAlpha = Math.abs(this.getZScore(alphaAdjusted));
                const zBeta = Math.abs(this.getZScore(beta));
                
                // åº”ç”¨å…¬å¼è®¡ç®—æ ·æœ¬é‡
                const n = Math.pow(sigma * (zAlpha + zBeta) / Math.abs(delta), 2);
                
                // å‘ä¸Šå–æ•´
                return Math.ceil(n);
            },
            
            // è®¡ç®—åŒæ ·æœ¬å‡å€¼æ£€éªŒçš„æ ·æœ¬é‡
            calculateTwoSampleMeanSampleSize(alpha, beta, delta, testDirection) {
                const sigma = parseFloat(document.getElementById('std-deviation').value);
                
                // æ ¹æ®æ£€éªŒæ–¹å‘è°ƒæ•´alphaå€¼
                const alphaAdjusted = testDirection === 'two-tailed' ? alpha / 2 : alpha;
                
                // è·å–Zåˆ†æ•°
                const zAlpha = Math.abs(this.getZScore(alphaAdjusted));
                const zBeta = Math.abs(this.getZScore(beta));
                
                // åº”ç”¨å…¬å¼è®¡ç®—æ ·æœ¬é‡ï¼ˆå‡è®¾ä¸¤ç»„æ ·æœ¬é‡ç›¸ç­‰ï¼‰
                const n = 2 * Math.pow(sigma * (zAlpha + zBeta) / Math.abs(delta), 2);
                
                // å‘ä¸Šå–æ•´
                return Math.ceil(n);
            },
            
            // è®¡ç®—æ¯”ä¾‹æ£€éªŒçš„æ ·æœ¬é‡
            calculateProportionSampleSize(alpha, beta, testDirection) {
                const p0 = parseFloat(document.getElementById('proportion-p0').value);
                const p1 = parseFloat(document.getElementById('proportion-p1').value);
                
                // æ ¹æ®æ£€éªŒæ–¹å‘è°ƒæ•´alphaå€¼
                const alphaAdjusted = testDirection === 'two-tailed' ? alpha / 2 : alpha;
                
                // è·å–Zåˆ†æ•°
                const zAlpha = Math.abs(this.getZScore(alphaAdjusted));
                const zBeta = Math.abs(this.getZScore(beta));
                
                // åº”ç”¨å…¬å¼è®¡ç®—æ ·æœ¬é‡
                const numerator = Math.pow(zAlpha * Math.sqrt(p0 * (1 - p0)) + zBeta * Math.sqrt(p1 * (1 - p1)), 2);
                const denominator = Math.pow(p1 - p0, 2);
                
                const n = numerator / denominator;
                
                // å‘ä¸Šå–æ•´
                return Math.ceil(n);
            },
            
            // è·å–å•æ ·æœ¬å‡å€¼æ£€éªŒå…¬å¼
            getOneSampleMeanFormula(testDirection) {
                if (testDirection === 'one-tailed') {
                    return 'n â‰ˆ [Ïƒ(zâ‚ + záµ¦) / Î”]Â²';
                } else {
                    return 'n â‰ˆ [Ïƒ(zâ‚/â‚‚ + záµ¦) / |Î”|]Â²';
                }
            },
            
            // è·å–åŒæ ·æœ¬å‡å€¼æ£€éªŒå…¬å¼
            getTwoSampleMeanFormula(testDirection) {
                if (testDirection === 'one-tailed') {
                    return 'n â‰ˆ 2[Ïƒ(zâ‚ + záµ¦) / Î”]Â²';
                } else {
                    return 'n â‰ˆ 2[Ïƒ(zâ‚/â‚‚ + záµ¦) / |Î”|]Â²';
                }
            },
            
            // è·å–æ¯”ä¾‹æ£€éªŒå…¬å¼
            getProportionFormula() {
                return 'n â‰ˆ [zâ‚âˆš(pâ‚€(1-pâ‚€)) + záµ¦âˆš(pâ‚(1-pâ‚))]Â² / (pâ‚-pâ‚€)Â²';
            },
            
            // æ˜¾ç¤ºåŠŸæ•ˆå‡½æ•°è®¡ç®—ç»“æœ
            displayPowerResults(n, alpha, power, effectSize, testType, testDirection, formula) {
                const resultsContainer = document.getElementById('power-results');
                const summaryElement = document.getElementById('power-summary');
                const formulaElement = document.getElementById('power-formula');
                
                // æ„å»ºç»“æœæ‘˜è¦
                let summaryHTML = '';
                summaryHTML += `<div class="stat-item"><span class="stat-label">æ‰€éœ€æ ·æœ¬é‡ (n):</span><span class="stat-value highlight">${n}</span></div>`;
                summaryHTML += `<div class="stat-item"><span class="stat-label">æ˜¾è‘—æ€§æ°´å¹³ (Î±):</span><span class="stat-value">${(alpha * 100).toFixed(1)}%</span></div>`;
                summaryHTML += `<div class="stat-item"><span class="stat-label">åŠŸæ•ˆ (1-Î²):</span><span class="stat-value">${(power * 100).toFixed(1)}%</span></div>`;
                summaryHTML += `<div class="stat-item"><span class="stat-label">æ•ˆåº”å¤§å° (Î”):</span><span class="stat-value">${effectSize.toFixed(2)}</span></div>`;
                
                let testTypeText = '';
                switch (testType) {
                    case 'one-sample-mean':
                        testTypeText = 'å•æ ·æœ¬å‡å€¼æ£€éªŒ';
                        const sigma = parseFloat(document.getElementById('std-deviation').value);
                        summaryHTML += `<div class="stat-item"><span class="stat-label">æ ‡å‡†å·® (Ïƒ):</span><span class="stat-value">${sigma.toFixed(2)}</span></div>`;
                        break;
                    case 'two-sample-mean':
                        testTypeText = 'åŒæ ·æœ¬å‡å€¼æ£€éªŒ';
                        const sigma2 = parseFloat(document.getElementById('std-deviation').value);
                        summaryHTML += `<div class="stat-item"><span class="stat-label">æ ‡å‡†å·® (Ïƒ):</span><span class="stat-value">${sigma2.toFixed(2)}</span></div>`;
                        break;
                    case 'proportion':
                        testTypeText = 'æ¯”ä¾‹æ£€éªŒ';
                        const p0 = parseFloat(document.getElementById('proportion-p0').value);
                        const p1 = parseFloat(document.getElementById('proportion-p1').value);
                        summaryHTML += `<div class="stat-item"><span class="stat-label">æ¯”ä¾‹ pâ‚€:</span><span class="stat-value">${p0.toFixed(2)}</span></div>`;
                        summaryHTML += `<div class="stat-item"><span class="stat-label">æ¯”ä¾‹ pâ‚:</span><span class="stat-value">${p1.toFixed(2)}</span></div>`;
                        break;
                }
                
                const directionText = testDirection === 'one-tailed' ? 'å•ä¾§æ£€éªŒ' : 'åŒä¾§æ£€éªŒ';
                summaryHTML += `<div class="stat-item"><span class="stat-label">æ£€éªŒç±»å‹:</span><span class="stat-value">${testTypeText}</span></div>`;
                summaryHTML += `<div class="stat-item"><span class="stat-label">æ£€éªŒæ–¹å‘:</span><span class="stat-value">${directionText}</span></div>`;
                
                // æ›´æ–°DOM
                summaryElement.innerHTML = summaryHTML;
                formulaElement.textContent = formula;
                
                // æ˜¾ç¤ºç»“æœå®¹å™¨
                resultsContainer.classList.remove('hidden');
                
                // å¦‚æœç”¨æˆ·é€‰æ‹©æ˜¾ç¤ºå›¾è¡¨ï¼Œæ›´æ–°å›¾è¡¨
                if (document.getElementById('show-power-chart').checked) {
                    this.updatePowerChart();
                }
            },
            
            // æ¸…é™¤åŠŸæ•ˆå‡½æ•°è®¡ç®—ç»“æœ
            clearPowerResults() {
                const resultsContainer = document.getElementById('power-results');
                const formulaContainer = document.getElementById('formula-container');
                const chartContainer = document.getElementById('power-chart-container');
                
                resultsContainer.classList.add('hidden');
                formulaContainer.classList.add('hidden');
                chartContainer.classList.add('hidden');
                
                // é‡ç½®å¤é€‰æ¡†
                document.getElementById('show-formula').checked = false;
                document.getElementById('show-power-chart').checked = false;
            },
            
            // æ ‡å‡†æ­£æ€åˆ†å¸ƒçš„ç´¯ç§¯åˆ†å¸ƒå‡½æ•°
            normalCDF(x) {
                return (1 + Math.erf(x / Math.sqrt(2))) / 2;
            },
            
            // æ›´æ–°åŠŸæ•ˆå‡½æ•°å›¾è¡¨
            updatePowerChart() {
                const ctx = document.getElementById('power-chart').getContext('2d');
                
                // é”€æ¯ç°æœ‰çš„å›¾è¡¨å®ä¾‹ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                if (this.powerChart) {
                    this.powerChart.destroy();
                }
                
                const testType = document.getElementById('power-analysis-type').value;
                const alpha = parseFloat(document.getElementById('alpha-value').value);
                const testDirection = document.getElementById('power-test-direction').value;
                
                // æ ¹æ®æ£€éªŒæ–¹å‘è°ƒæ•´alphaå€¼
                const alphaAdjusted = testDirection === 'two-tailed' ? alpha / 2 : alpha;
                const zAlpha = Math.abs(this.getZScore(alphaAdjusted));
                
                let xValues = [];
                let powerValues = [];
                let chartTitle = '';
                let xAxisLabel = '';
                
                // æ ¹æ®æ£€éªŒç±»å‹ç”ŸæˆåŠŸæ•ˆå‡½æ•°æ•°æ®
                switch (testType) {
                    case 'one-sample-mean':
                        {
                            const sigma = parseFloat(document.getElementById('std-deviation').value);
                            const n = parseInt(document.getElementById('power-summary').querySelector('.highlight').textContent);
                            
                            // ç”Ÿæˆæ•ˆåº”å¤§å°èŒƒå›´
                            const baseEffectSize = parseFloat(document.getElementById('effect-size').value);
                            const minEffect = Math.max(0.1, baseEffectSize / 3);
                            const maxEffect = Math.min(3, baseEffectSize * 2);
                            const step = (maxEffect - minEffect) / 20;
                            
                            for (let d = minEffect; d <= maxEffect; d += step) {
                                xValues.push(d);
                                
                                // è®¡ç®—åŠŸæ•ˆ
                                let power;
                                if (testDirection === 'one-tailed') {
                                    // å•ä¾§æ£€éªŒåŠŸæ•ˆè®¡ç®—
                                    const zBeta = (d * Math.sqrt(n) / sigma) - zAlpha;
                                    power = 1 - this.normalCDF(-zBeta);
                                } else {
                                    // åŒä¾§æ£€éªŒåŠŸæ•ˆè®¡ç®—
                                    const zBetaLower = (d * Math.sqrt(n) / sigma) - zAlpha;
                                    const zBetaUpper = (-d * Math.sqrt(n) / sigma) - zAlpha;
                                    power = 1 - this.normalCDF(-zBetaLower) + this.normalCDF(zBetaUpper);
                                }
                                
                                powerValues.push(Math.min(1, Math.max(0, power)));
                            }
                            
                            chartTitle = 'å•æ ·æœ¬å‡å€¼æ£€éªŒåŠŸæ•ˆå‡½æ•°';
                            xAxisLabel = 'æ•ˆåº”å¤§å° (Î”)';
                        }
                        break;
                    
                    case 'two-sample-mean':
                        {
                            const sigma = parseFloat(document.getElementById('std-deviation').value);
                            const n = parseInt(document.getElementById('power-summary').querySelector('.highlight').textContent);
                            const nPerGroup = Math.ceil(n / 2); // æ¯ç»„æ ·æœ¬é‡
                            
                            // ç”Ÿæˆæ•ˆåº”å¤§å°èŒƒå›´
                            const baseEffectSize = parseFloat(document.getElementById('effect-size').value);
                            const minEffect = Math.max(0.1, baseEffectSize / 3);
                            const maxEffect = Math.min(3, baseEffectSize * 2);
                            const step = (maxEffect - minEffect) / 20;
                            
                            for (let d = minEffect; d <= maxEffect; d += step) {
                                xValues.push(d);
                                
                                // è®¡ç®—åŠŸæ•ˆ
                                let power;
                                if (testDirection === 'one-tailed') {
                                    // å•ä¾§æ£€éªŒåŠŸæ•ˆè®¡ç®—
                                    const zBeta = (d * Math.sqrt(nPerGroup) / (sigma * Math.sqrt(2))) - zAlpha;
                                    power = 1 - this.normalCDF(-zBeta);
                                } else {
                                    // åŒä¾§æ£€éªŒåŠŸæ•ˆè®¡ç®—
                                    const zBetaLower = (d * Math.sqrt(nPerGroup) / (sigma * Math.sqrt(2))) - zAlpha;
                                    const zBetaUpper = (-d * Math.sqrt(nPerGroup) / (sigma * Math.sqrt(2))) - zAlpha;
                                    power = 1 - this.normalCDF(-zBetaLower) + this.normalCDF(zBetaUpper);
                                }
                                
                                powerValues.push(Math.min(1, Math.max(0, power)));
                            }
                            
                            chartTitle = 'åŒæ ·æœ¬å‡å€¼æ£€éªŒåŠŸæ•ˆå‡½æ•°';
                            xAxisLabel = 'æ•ˆåº”å¤§å° (Î”)';
                        }
                        break;
                    
                    case 'proportion':
                        {
                            const p0 = parseFloat(document.getElementById('proportion-p0').value);
                            const p1 = parseFloat(document.getElementById('proportion-p1').value);
                            const n = parseInt(document.getElementById('power-summary').querySelector('.highlight').textContent);
                            
                            // ç”Ÿæˆæ¯”ä¾‹å·®å€¼èŒƒå›´
                            const baseDiff = Math.abs(p1 - p0);
                            const minDiff = Math.max(0.05, baseDiff / 3);
                            const maxDiff = Math.min(0.5, baseDiff * 2);
                            const step = (maxDiff - minDiff) / 20;
                            
                            for (let diff = minDiff; diff <= maxDiff; diff += step) {
                                xValues.push(diff);
                                
                                // è®¡ç®—åŠŸæ•ˆ
                                let p1Current = p0 + (p1 > p0 ? diff : -diff);
                                p1Current = Math.max(0.01, Math.min(0.99, p1Current));
                                
                                let power;
                                if (testDirection === 'one-tailed') {
                                    // å•ä¾§æ£€éªŒåŠŸæ•ˆè®¡ç®—
                                    const se0 = Math.sqrt(p0 * (1 - p0) / n);
                                    const criticalValue = this.getZScore(1 - alpha) * se0 + p0;
                                    
                                    const se1 = Math.sqrt(p1Current * (1 - p1Current) / n);
                                    const z = (criticalValue - p1Current) / se1;
                                    power = this.normalCDF(z);
                                } else {
                                    // åŒä¾§æ£€éªŒåŠŸæ•ˆè®¡ç®—
                                    const se0 = Math.sqrt(p0 * (1 - p0) / n);
                                    const criticalValueLower = this.getZScore(alpha / 2) * se0 + p0;
                                    const criticalValueUpper = this.getZScore(1 - alpha / 2) * se0 + p0;
                                    
                                    const se1 = Math.sqrt(p1Current * (1 - p1Current) / n);
                                    const zLower = (criticalValueLower - p1Current) / se1;
                                    const zUpper = (criticalValueUpper - p1Current) / se1;
                                    power = this.normalCDF(zLower) + (1 - this.normalCDF(zUpper));
                                }
                                
                                powerValues.push(Math.min(1, Math.max(0, power)));
                            }
                            
                            chartTitle = 'æ¯”ä¾‹æ£€éªŒåŠŸæ•ˆå‡½æ•°';
                            xAxisLabel = 'æ¯”ä¾‹å·®å€¼ |pâ‚ - pâ‚€|';
                        }
                        break;
                }
                
                // åˆ›å»ºå›¾è¡¨
                this.powerChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: xValues.map(val => val.toFixed(3)),
                        datasets: [{
                            label: 'åŠŸæ•ˆå€¼',
                            data: powerValues,
                            borderColor: 'rgb(75, 192, 192)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            borderWidth: 2,
                            tension: 0.3,
                            fill: true
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: chartTitle,
                                font: {
                                    size: 16
                                }
                            },
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return `åŠŸæ•ˆ: ${(context.parsed.y * 100).toFixed(1)}%`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: xAxisLabel
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'åŠŸæ•ˆå€¼ (1-Î²)'
                                },
                                min: 0,
                                max: 1.0,
                                ticks: {
                                    callback: function(value) {
                                        return (value * 100) + '%';
                                    }
                                }
                            }
                        }
                    }
                });
            },
            
            // å‡è®¾æ£€éªŒç›¸å…³æ–¹æ³•
            initHypothesisTesting() {
                // ç¡®ä¿Math.erfå‡½æ•°å¯ç”¨ï¼Œè¿™å¯¹æ­£æ€åˆ†å¸ƒè®¡ç®—è‡³å…³é‡è¦
                this.ensureMathErf();
                
                // æ£€éªŒç±»å‹å˜åŒ–äº‹ä»¶
                const testTypeElement = document.getElementById('test-type');
                if (testTypeElement) {
                    testTypeElement.addEventListener('change', () => {
                        try {
                            this.toggleTestParameters();
                        } catch (error) {
                            console.error('åˆ‡æ¢æ£€éªŒå‚æ•°æ—¶å‡ºé”™:', error);
                        }
                    });
                }
                
                // æ ·æœ¬æ–¹æ³•å˜åŒ–äº‹ä»¶
                const sampleMethodElement = document.getElementById('sample-method');
                const manualSampleElement = document.getElementById('manual-sample-input');
                if (sampleMethodElement && manualSampleElement) {
                    sampleMethodElement.addEventListener('change', () => {
                        try {
                            const method = sampleMethodElement.value;
                            manualSampleElement.classList.toggle('hidden', method !== 'manual-entry');
                        } catch (error) {
                            console.error('åˆ‡æ¢æ ·æœ¬æ–¹æ³•æ—¶å‡ºé”™:', error);
                        }
                    });
                }
                
                // è®¡ç®—æ£€éªŒæŒ‰é’®äº‹ä»¶
                const calculateButton = document.getElementById('calculate-test');
                if (calculateButton) {
                    calculateButton.addEventListener('click', () => {
                        try {
                            this.calculateHypothesisTest();
                        } catch (error) {
                            console.error('è®¡ç®—å‡è®¾æ£€éªŒæ—¶å‡ºé”™:', error);
                            alert('è®¡ç®—é”™è¯¯: ' + error.message);
                        }
                    });
                }
                
                // æ¸…é™¤ç»“æœæŒ‰é’®äº‹ä»¶
                const clearButton = document.getElementById('clear-test-results');
                if (clearButton) {
                    clearButton.addEventListener('click', () => {
                        try {
                            this.clearTestResults();
                        } catch (error) {
                            console.error('æ¸…é™¤æ£€éªŒç»“æœæ—¶å‡ºé”™:', error);
                        }
                    });
                }
                
                // åˆå§‹è°ƒç”¨ä¸€æ¬¡å‚æ•°åˆ‡æ¢å‡½æ•°
                try {
                    this.toggleTestParameters();
                } catch (error) {
                    console.error('åˆå§‹åŒ–æ£€éªŒå‚æ•°æ—¶å‡ºé”™:', error);
                }
            },
            
            toggleTestParameters() {
                const testType = document.getElementById('test-type').value;
                
                // æ˜¾ç¤º/éšè—ä¸åŒæ£€éªŒç±»å‹çš„å‚æ•°åŒºåŸŸ
                document.getElementById('one-sample-params').classList.toggle('hidden', 
                    testType !== 'z-test' && testType !== 't-test');
                document.getElementById('two-sample-params').classList.toggle('hidden', 
                    testType !== 'two-sample-t');
                document.getElementById('anova-params').classList.toggle('hidden', 
                    testType !== 'anova');
                
                // å¯¹äºæ–¹å·®åˆ†æï¼Œé»˜è®¤ä½¿ç”¨æ‰‹åŠ¨è¾“å…¥
                if (testType === 'anova') {
                    document.getElementById('sample-method').value = 'manual-entry';
                    document.getElementById('manual-sample-input').classList.remove('hidden');
                }
            },
            
            calculateHypothesisTest() {
                try {
                    const testType = document.getElementById('test-type').value;
                    const significanceLevel = parseFloat(document.getElementById('significance-level').value);
                    
                    // éªŒè¯æ˜¾è‘—æ€§æ°´å¹³
                    if (isNaN(significanceLevel) || significanceLevel <= 0 || significanceLevel >= 1) {
                        throw new Error('æ˜¾è‘—æ€§æ°´å¹³å¿…é¡»æ˜¯0åˆ°1ä¹‹é—´çš„æ•°å€¼');
                    }
                    
                    let results = null;
                    
                    switch(testType) {
                        case 'z-test':
                            const hypothesizedMeanZ = parseFloat(document.getElementById('population-mean').value);
                            if (isNaN(hypothesizedMeanZ)) {
                                throw new Error('è¯·è¾“å…¥æœ‰æ•ˆçš„å‡è®¾å‡å€¼');
                            }
                            results = this.calculateZTest(significanceLevel, hypothesizedMeanZ);
                            break;
                        case 't-test':
                            const hypothesizedMeanT = parseFloat(document.getElementById('population-mean').value);
                            if (isNaN(hypothesizedMeanT)) {
                                throw new Error('è¯·è¾“å…¥æœ‰æ•ˆçš„å‡è®¾å‡å€¼');
                            }
                            results = this.calculateTTest(significanceLevel, hypothesizedMeanT);
                            break;
                        case 'two-sample-t':
                            const testDirectionT = document.getElementById('test-direction').value;
                            results = this.calculateTwoSampleTTest(significanceLevel, testDirectionT);
                            break;
                        case 'anova':
                            results = this.calculateANOVA(significanceLevel);
                            break;
                        default:
                            throw new Error('æœªçŸ¥çš„æ£€éªŒç±»å‹');
                    }
                    
                    if (results) {
                        this.displayTestResults(results);
                    }
                } catch (error) {
                    console.error('å‡è®¾æ£€éªŒè®¡ç®—é”™è¯¯:', error);
                    alert('è®¡ç®—é”™è¯¯: ' + error.message);
                }
            },
            
            calculateZTest(significanceLevel, hypothesizedMean) {
                // ä»DOMè·å–æ£€éªŒæ–¹å‘
                const testDirection = document.getElementById('test-direction').value;
                const populationStd = document.getElementById('population-std').value;
                
                // éªŒè¯æ•°æ®å’Œå‚æ•°
                if (!this.generatedData || this.generatedData.length === 0) {
                    throw new Error('è¯·å…ˆåœ¨æ¦‚ç‡åˆ†å¸ƒæ¨¡æ‹Ÿæˆ–æ•°æ®åˆ†æä¸­ç”Ÿæˆæˆ–å¯¼å…¥æ•°æ®');
                }
                
                // éªŒè¯æ€»ä½“æ ‡å‡†å·®
                if (!populationStd || isNaN(populationStd) || parseFloat(populationStd) <= 0) {
                    throw new Error('è¯·è¾“å…¥æœ‰æ•ˆçš„æ€»ä½“æ ‡å‡†å·®');
                }
                
                const populationStdFloat = parseFloat(populationStd);
                
                // è®¡ç®—æ ·æœ¬ç»Ÿè®¡é‡
                const sampleMean = this.calculateMean(this.generatedData);
                const sampleSize = this.generatedData.length;
                const standardError = populationStdFloat / Math.sqrt(sampleSize);
                const zScore = (sampleMean - hypothesizedMean) / standardError;
                
                // è®¡ç®—på€¼
                let pValue;
                const cumulativeProbability = this.normalCDF(zScore);
                
                switch(testDirection) {
                    case 'two-tailed':
                        pValue = 2 * Math.min(cumulativeProbability, 1 - cumulativeProbability);
                        break;
                    case 'left-tailed':
                        pValue = cumulativeProbability;
                        break;
                    case 'right-tailed':
                        pValue = 1 - cumulativeProbability;
                        break;
                }
                
                // è®¡ç®—ä¸´ç•Œå€¼
                let criticalValue;
                const alpha = significanceLevel;
                
                if (testDirection === 'two-tailed') {
                    criticalValue = this.getZScore(1 - alpha/2);
                } else if (testDirection === 'left-tailed') {
                    criticalValue = -this.getZScore(1 - alpha);
                } else {
                    criticalValue = this.getZScore(1 - alpha);
                }
                
                const rejectNull = pValue < significanceLevel;
                
                return {
                    testType: 'Zæ£€éªŒ',
                    sampleMean,
                    hypothesizedMean,
                    sampleSize,
                    zScore,
                    pValue,
                    criticalValue,
                    significanceLevel,
                    rejectNull,
                    testDirection,
                    resultMessage: rejectNull ? 
                        `åœ¨æ˜¾è‘—æ€§æ°´å¹³ Î± = ${significanceLevel} ä¸‹ï¼Œæ‹’ç»åŸå‡è®¾` : 
                        `åœ¨æ˜¾è‘—æ€§æ°´å¹³ Î± = ${significanceLevel} ä¸‹ï¼Œä¸æ‹’ç»åŸå‡è®¾`
                };
            },
            
            calculateTTest(significanceLevel, hypothesizedMean) {
                // ä»DOMè·å–æ£€éªŒæ–¹å‘
                const testDirection = document.getElementById('test-direction').value;
                
                if (!this.generatedData || this.generatedData.length === 0) {
                    throw new Error('è¯·å…ˆåœ¨æ¦‚ç‡åˆ†å¸ƒæ¨¡æ‹Ÿæˆ–æ•°æ®åˆ†æä¸­ç”Ÿæˆæˆ–å¯¼å…¥æ•°æ®');
                }
                
                // è®¡ç®—æ ·æœ¬ç»Ÿè®¡é‡
                const sampleMean = this.calculateMean(this.generatedData);
                const sampleStd = this.calculateStandardDeviation(this.generatedData);
                const sampleSize = this.generatedData.length;
                const degreesOfFreedom = sampleSize - 1;
                const standardError = sampleStd / Math.sqrt(sampleSize);
                const tScore = (sampleMean - hypothesizedMean) / standardError;
                
                // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œä½¿ç”¨è¿‘ä¼¼çš„tåˆ†å¸ƒpå€¼è®¡ç®—
                const pValue = this.approximateTPValue(tScore, degreesOfFreedom, testDirection);
                
                // è®¡ç®—ä¸´ç•Œå€¼
                let criticalValue = this.approximateTCriticalValue(degreesOfFreedom, significanceLevel, testDirection);
                
                const rejectNull = pValue < significanceLevel;
                
                return {
                    testType: 'Tæ£€éªŒ',
                    sampleMean,
                    hypothesizedMean,
                    sampleStd,
                    sampleSize,
                    degreesOfFreedom,
                    tScore,
                    pValue,
                    criticalValue,
                    significanceLevel,
                    rejectNull,
                    testDirection,
                    resultMessage: rejectNull ? 
                        `åœ¨æ˜¾è‘—æ€§æ°´å¹³ Î± = ${significanceLevel} ä¸‹ï¼Œæ‹’ç»åŸå‡è®¾` : 
                        `åœ¨æ˜¾è‘—æ€§æ°´å¹³ Î± = ${significanceLevel} ä¸‹ï¼Œä¸æ‹’ç»åŸå‡è®¾`
                };
            },
            
            calculateTwoSampleTTest(significanceLevel, testDirection) {
                let sample1, sample2;
                
                const sampleMethod = document.getElementById('sample-method').value;
                
                if (sampleMethod === 'use-generated') {
                    if (!this.generatedData || this.generatedData.length < 2) {
                        throw new Error('ä½¿ç”¨å·²ç”Ÿæˆæ•°æ®éœ€è¦è‡³å°‘2ä¸ªæ•°æ®ç‚¹');
                    }
                    // ç®€å•åœ°å°†æ•°æ®åˆ†æˆä¸¤åŠ
                    const midPoint = Math.floor(this.generatedData.length / 2);
                    sample1 = this.generatedData.slice(0, midPoint);
                    sample2 = this.generatedData.slice(midPoint);
                } else {
                    // æ‰‹åŠ¨è¾“å…¥
                    const sample1Text = document.getElementById('sample1-data').value.trim();
                    const sample2Text = document.getElementById('sample2-data').value.trim();
                    
                    if (!sample1Text || !sample2Text) {
                        throw new Error('è¯·è¾“å…¥ä¸¤ä¸ªæ ·æœ¬çš„æ•°æ®');
                    }
                    
                    sample1 = sample1Text.split(',').map(x => parseFloat(x.trim())).filter(x => !isNaN(x));
                    sample2 = sample2Text.split(',').map(x => parseFloat(x.trim())).filter(x => !isNaN(x));
                    
                    if (sample1.length === 0 || sample2.length === 0) {
                        throw new Error('æ ·æœ¬æ•°æ®æ ¼å¼é”™è¯¯ï¼Œè¯·ä½¿ç”¨é€—å·åˆ†éš”çš„æ•°å­—');
                    }
                }
                
                // è®¡ç®—æ ·æœ¬ç»Ÿè®¡é‡
                const mean1 = this.calculateMean(sample1);
                const mean2 = this.calculateMean(sample2);
                const std1 = this.calculateStandardDeviation(sample1);
                const std2 = this.calculateStandardDeviation(sample2);
                const n1 = sample1.length;
                const n2 = sample2.length;
                
                // è®¡ç®—åˆå¹¶æ ‡å‡†å·®
                const pooledVariance = ((n1 - 1) * std1 * std1 + (n2 - 1) * std2 * std2) / (n1 + n2 - 2);
                const standardError = Math.sqrt(pooledVariance * (1/n1 + 1/n2));
                const tScore = (mean1 - mean2) / standardError;
                const degreesOfFreedom = n1 + n2 - 2;
                
                // è¿‘ä¼¼på€¼
                const pValue = this.approximateTPValue(tScore, degreesOfFreedom, testDirection);
                
                const rejectNull = pValue < significanceLevel;
                
                return {
                    testType: 'åŒæ ·æœ¬Tæ£€éªŒ',
                    mean1,
                    mean2,
                    std1,
                    std2,
                    n1,
                    n2,
                    degreesOfFreedom,
                    tScore,
                    pValue,
                    significanceLevel,
                    rejectNull,
                    testDirection,
                    resultMessage: rejectNull ? 
                        `åœ¨æ˜¾è‘—æ€§æ°´å¹³ Î± = ${significanceLevel} ä¸‹ï¼Œæ‹’ç»åŸå‡è®¾ï¼ˆä¸¤ä¸ªæ€»ä½“å‡å€¼ç›¸ç­‰ï¼‰` : 
                        `åœ¨æ˜¾è‘—æ€§æ°´å¹³ Î± = ${significanceLevel} ä¸‹ï¼Œä¸æ‹’ç»åŸå‡è®¾ï¼ˆä¸¤ä¸ªæ€»ä½“å‡å€¼ç›¸ç­‰ï¼‰`
                };
            },
            
            calculateANOVA(significanceLevel) {
                const sample1Text = document.getElementById('sample1-data').value.trim();
                const sample2Text = document.getElementById('sample2-data').value.trim();
                
                if (!sample1Text || !sample2Text) {
                    throw new Error('æ–¹å·®åˆ†æéœ€è¦è‡³å°‘ä¸¤ä¸ªæ ·æœ¬çš„æ•°æ®');
                }
                
                const sample1 = sample1Text.split(',').map(x => parseFloat(x.trim())).filter(x => !isNaN(x));
                const sample2 = sample2Text.split(',').map(x => parseFloat(x.trim())).filter(x => !isNaN(x));
                
                if (sample1.length === 0 || sample2.length === 0) {
                    throw new Error('æ ·æœ¬æ•°æ®æ ¼å¼é”™è¯¯ï¼Œè¯·ä½¿ç”¨é€—å·åˆ†éš”çš„æ•°å­—');
                }
                
                const groups = [sample1, sample2];
                const k = groups.length; // ç»„æ•°
                const n = groups.reduce((sum, group) => sum + group.length, 0); // æ€»æ ·æœ¬æ•°
                
                // è®¡ç®—å„ç»„å‡å€¼å’Œæ€»å‡å€¼
                const groupMeans = groups.map(group => this.calculateMean(group));
                const grandMean = this.calculateMean(groups.flat());
                
                // è®¡ç®—ç»„é—´å¹³æ–¹å’Œ
                let ssb = 0;
                groups.forEach((group, index) => {
                    ssb += group.length * Math.pow(groupMeans[index] - grandMean, 2);
                });
                
                // è®¡ç®—ç»„å†…å¹³æ–¹å’Œ
                let ssw = 0;
                groups.forEach((group, index) => {
                    group.forEach(value => {
                        ssw += Math.pow(value - groupMeans[index], 2);
                    });
                });
                
                // è®¡ç®—å‡æ–¹
                const msb = ssb / (k - 1); // ç»„é—´å‡æ–¹
                const msw = ssw / (n - k); // ç»„å†…å‡æ–¹
                
                // è®¡ç®—Fç»Ÿè®¡é‡
                const fStatistic = msb / msw;
                
                // ç®€åŒ–çš„på€¼è®¡ç®—
                const pValue = this.approximateFPValue(fStatistic, k - 1, n - k);
                
                const rejectNull = pValue < significanceLevel;
                
                return {
                    testType: 'å•å› ç´ æ–¹å·®åˆ†æ',
                    groups: k,
                    totalSamples: n,
                    groupMeans,
                    grandMean,
                    fStatistic,
                    degreesOfFreedom: `${k-1}, ${n-k}`,
                    pValue,
                    significanceLevel,
                    rejectNull,
                    resultMessage: rejectNull ? 
                        `åœ¨æ˜¾è‘—æ€§æ°´å¹³ Î± = ${significanceLevel} ä¸‹ï¼Œæ‹’ç»åŸå‡è®¾ï¼ˆå„ç»„å‡å€¼ç›¸ç­‰ï¼‰` : 
                        `åœ¨æ˜¾è‘—æ€§æ°´å¹³ Î± = ${significanceLevel} ä¸‹ï¼Œä¸æ‹’ç»åŸå‡è®¾ï¼ˆå„ç»„å‡å€¼ç›¸ç­‰ï¼‰`
                };
            },
            
            displayTestResults(results) {
                const summaryContainer = document.getElementById('test-summary');
                summaryContainer.innerHTML = '';
                
                // åˆ›å»ºç»“æœå¡ç‰‡
                const createStatCard = (title, value, description = '') => {
                    const card = document.createElement('div');
                    card.className = 'stat-card';
                    card.innerHTML = `
                        <h4>${title}</h4>
                        <div class="stat-value">${value}</div>
                        ${description ? `<div class="stat-description">${description}</div>` : ''}
                    `;
                    summaryContainer.appendChild(card);
                };
                
                // æ ¹æ®æ£€éªŒç±»å‹æ˜¾ç¤ºä¸åŒçš„ç»“æœ
                if (results.testType === 'Zæ£€éªŒ' || results.testType === 'Tæ£€éªŒ') {
                    createStatCard('æ£€éªŒç±»å‹', results.testType);
                    createStatCard('æ ·æœ¬å‡å€¼', results.sampleMean ? results.sampleMean.toFixed(4) : 'N/A');
                    createStatCard('å‡è®¾å‡å€¼', results.hypothesizedMean);
                    createStatCard('æ ·æœ¬é‡', results.sampleSize);
                    
                    if (results.testType === 'Zæ£€éªŒ') {
                        createStatCard('Zç»Ÿè®¡é‡', results.zScore ? results.zScore.toFixed(4) : 'N/A');
                    } else {
                        createStatCard('Tç»Ÿè®¡é‡', results.tScore ? results.tScore.toFixed(4) : 'N/A');
                        createStatCard('è‡ªç”±åº¦', results.degreesOfFreedom);
                    }
                    
                    createStatCard('På€¼', results.pValue ? results.pValue.toFixed(6) : 'N/A');
                    createStatCard('æ˜¾è‘—æ€§æ°´å¹³', results.significanceLevel);
                    
                    const resultCard = document.createElement('div');
                    resultCard.className = 'stat-card ' + (results.rejectNull ? 'highlight-reject' : 'highlight-accept');
                    resultCard.innerHTML = `
                        <h4>æ£€éªŒç»“è®º</h4>
                        <div class="stat-value">${results.resultMessage}</div>
                    `;
                    summaryContainer.appendChild(resultCard);
                    
                    // ç»˜åˆ¶å›¾è¡¨
                    this.plotTestChart(results);
                } else if (results.testType === 'åŒæ ·æœ¬Tæ£€éªŒ') {
                    createStatCard('æ£€éªŒç±»å‹', results.testType);
                    createStatCard('æ ·æœ¬1å‡å€¼', results.mean1 ? results.mean1.toFixed(4) : 'N/A');
                    createStatCard('æ ·æœ¬2å‡å€¼', results.mean2 ? results.mean2.toFixed(4) : 'N/A');
                    createStatCard('æ ·æœ¬1æ ‡å‡†å·®', results.std1 ? results.std1.toFixed(4) : 'N/A');
                    createStatCard('æ ·æœ¬2æ ‡å‡†å·®', results.std2 ? results.std2.toFixed(4) : 'N/A');
                    createStatCard('æ ·æœ¬1é‡', results.n1);
                    createStatCard('æ ·æœ¬2é‡', results.n2);
                    createStatCard('Tç»Ÿè®¡é‡', results.tScore ? results.tScore.toFixed(4) : 'N/A');
                    createStatCard('è‡ªç”±åº¦', results.degreesOfFreedom);
                    createStatCard('På€¼', results.pValue ? results.pValue.toFixed(6) : 'N/A');
                    createStatCard('æ˜¾è‘—æ€§æ°´å¹³', results.significanceLevel);
                    
                    const resultCard = document.createElement('div');
                    resultCard.className = 'stat-card ' + (results.rejectNull ? 'highlight-reject' : 'highlight-accept');
                    resultCard.innerHTML = `
                        <h4>æ£€éªŒç»“è®º</h4>
                        <div class="stat-value">${results.resultMessage}</div>
                    `;
                    summaryContainer.appendChild(resultCard);
                } else if (results.testType === 'å•å› ç´ æ–¹å·®åˆ†æ') {
                    createStatCard('æ£€éªŒç±»å‹', results.testType);
                    createStatCard('ç»„æ•°', results.groups);
                    createStatCard('æ€»æ ·æœ¬æ•°', results.totalSamples);
                    createStatCard('Fç»Ÿè®¡é‡', results.fStatistic ? results.fStatistic.toFixed(4) : 'N/A');
                    createStatCard('è‡ªç”±åº¦', results.degreesOfFreedom);
                    createStatCard('På€¼', results.pValue ? results.pValue.toFixed(6) : 'N/A');
                    createStatCard('æ˜¾è‘—æ€§æ°´å¹³', results.significanceLevel);
                    
                    // æ˜¾ç¤ºå„ç»„å‡å€¼
                    if (results.groupMeans && Array.isArray(results.groupMeans)) {
                        results.groupMeans.forEach((mean, index) => {
                            createStatCard(`ç»„ ${index + 1} å‡å€¼`, mean ? mean.toFixed(4) : 'N/A');
                        });
                    }
                    
                    createStatCard('æ€»å‡å€¼', results.grandMean ? results.grandMean.toFixed(4) : 'N/A');
                    
                    const resultCard = document.createElement('div');
                    resultCard.className = 'stat-card ' + (results.rejectNull ? 'highlight-reject' : 'highlight-accept');
                    resultCard.innerHTML = `
                        <h4>æ£€éªŒç»“è®º</h4>
                        <div class="stat-value">${results.resultMessage}</div>
                    `;
                    summaryContainer.appendChild(resultCard);
                }
                
                // æ˜¾ç¤ºç»“æœåŒºåŸŸ
                document.getElementById('test-results').classList.remove('hidden');
                document.getElementById('test-chart-container').classList.remove('hidden');
            },
            
            plotTestChart(results) {
                try {
                    const ctx = document.getElementById('test-chart')?.getContext('2d');
                    if (!ctx) {
                        console.error('å›¾è¡¨ä¸Šä¸‹æ–‡æœªæ‰¾åˆ°');
                        return;
                    }
                    
                    // é”€æ¯æ—§å›¾è¡¨
                    if (this.testChart) {
                        this.testChart.destroy();
                    }
                    
                    let chartData = null;
                    let chartOptions = null;
                    
                    if (results.testType === 'Zæ£€éªŒ' || results.testType === 'Tæ£€éªŒ') {
                        // ä¸ºZæ£€éªŒæˆ–Tæ£€éªŒåˆ›å»ºåˆ†å¸ƒå›¾
                        const xValues = [];
                        const distributionValues = [];
                        const testStat = results.testType === 'Zæ£€éªŒ' ? results.zScore : results.tScore;
                        
                        // éªŒè¯å¿…è¦çš„æ•°æ®å­˜åœ¨
                        if (testStat === undefined || testStat === null) {
                            console.error('æ£€éªŒç»Ÿè®¡é‡ä¸å­˜åœ¨');
                            return;
                        }
                        
                        // ç”Ÿæˆåˆ†å¸ƒæ›²çº¿æ•°æ®
                        const min = Math.min(-4, testStat - 1);
                        const max = Math.max(4, testStat + 1);
                        for (let x = min; x <= max; x += 0.1) {
                            xValues.push(x);
                            if (results.testType === 'Zæ£€éªŒ') {
                                distributionValues.push(this.normalPDF(x));
                            } else if (results.degreesOfFreedom) {
                                distributionValues.push(this.tDistributionPDF(x, results.degreesOfFreedom));
                            } else {
                                distributionValues.push(0); // é¿å…è‡ªç”±åº¦ä¸å­˜åœ¨å¯¼è‡´çš„é”™è¯¯
                            }
                        }
                        
                        // åˆ›å»ºpå€¼åŒºåŸŸæ•°æ®
                        const pValueArea = [];
                        const testDirection = results.testDirection || 'two-tailed';
                        
                        if (testDirection === 'two-tailed') {
                            // åŒä¾§æ£€éªŒ
                            for (let i = 0; i < xValues.length; i++) {
                                if (Math.abs(xValues[i]) >= Math.abs(testStat)) {
                                    pValueArea.push(distributionValues[i]);
                                } else {
                                    pValueArea.push(null);
                                }
                            }
                        } else if (testDirection === 'right-tailed') {
                            // å³ä¾§æ£€éªŒ
                            for (let i = 0; i < xValues.length; i++) {
                                if (xValues[i] >= testStat) {
                                    pValueArea.push(distributionValues[i]);
                                } else {
                                    pValueArea.push(null);
                                }
                            }
                        } else {
                            // å·¦ä¾§æ£€éªŒ
                            for (let i = 0; i < xValues.length; i++) {
                                if (xValues[i] <= testStat) {
                                    pValueArea.push(distributionValues[i]);
                                } else {
                                    pValueArea.push(null);
                                }
                            }
                        }
                        
                        // å®šä¹‰å›¾è¡¨æ•°æ®
                        chartData = {
                            labels: xValues,
                            datasets: [
                                {
                                    label: results.testType === 'Zæ£€éªŒ' ? 'æ ‡å‡†æ­£æ€åˆ†å¸ƒ' : 'Tåˆ†å¸ƒ',
                                    data: distributionValues,
                                    borderColor: 'blue',
                                    backgroundColor: 'rgba(54, 162, 235, 0.1)',
                                    borderWidth: 2,
                                    fill: false,
                                    tension: 0.4
                                },
                                {
                                    label: 'på€¼åŒºåŸŸ',
                                    data: pValueArea,
                                    borderColor: 'red',
                                    backgroundColor: 'rgba(255, 99, 132, 0.3)',
                                    borderWidth: 0,
                                    fill: true
                                }
                            ]
                        };
                        
                        // å®šä¹‰å›¾è¡¨é€‰é¡¹
                        chartOptions = {
                            responsive: true,
                            plugins: {
                                title: {
                                    display: true,
                                    text: `${results.testType} åˆ†å¸ƒä¸på€¼å¯è§†åŒ–`
                                },
                                legend: {
                                    position: 'top'
                                }
                            },
                            scales: {
                                x: {
                                    title: {
                                        display: true,
                                        text: results.testType === 'Zæ£€éªŒ' ? 'Zå€¼' : 'Tå€¼'
                                    }
                                },
                                y: {
                                    title: {
                                        display: true,
                                        text: 'æ¦‚ç‡å¯†åº¦'
                                    },
                                    min: 0
                                }
                            }
                        };
                    }
                    
                    // åˆ›å»ºæ–°å›¾è¡¨
                    if (chartData && chartOptions && typeof Chart !== 'undefined') {
                        try {
                            this.testChart = new Chart(ctx, {
                                type: 'line',
                                data: chartData,
                                options: chartOptions
                            });
                        } catch (chartError) {
                            console.error('å›¾è¡¨åˆ›å»ºå¤±è´¥:', chartError);
                        }
                    }
                } catch (error) {
                    console.error('å›¾è¡¨å¤„ç†é”™è¯¯:', error);
                }
            },
              
              clearTestResults() {
                document.getElementById('test-results').classList.add('hidden');
                document.getElementById('test-chart-container').classList.add('hidden');
                
                if (this.testChart) {
                    this.testChart.destroy();
                    this.testChart = null;
                }
            },
            
            // ç¼ºå¤±çš„Zæ£€éªŒè®¡ç®—æ–¹æ³•
            calculateZTest(significanceLevel, hypothesizedMean, testDirection) {
                if (!this.generatedData || this.generatedData.length === 0) {
                    throw new Error('è¯·å…ˆåœ¨æ¦‚ç‡åˆ†å¸ƒæ¨¡æ‹Ÿæˆ–æ•°æ®åˆ†æä¸­ç”Ÿæˆæˆ–å¯¼å…¥æ•°æ®');
                }
                
                // è®¡ç®—æ ·æœ¬ç»Ÿè®¡é‡
                const sampleMean = this.calculateMean(this.generatedData);
                const populationStd = document.getElementById('population-std').value;
                
                // éªŒè¯æ€»ä½“æ ‡å‡†å·®æ˜¯å¦æœ‰æ•ˆ
                if (!populationStd || isNaN(populationStd) || parseFloat(populationStd) <= 0) {
                    throw new Error('è¯·è¾“å…¥æœ‰æ•ˆçš„æ€»ä½“æ ‡å‡†å·®');
                }
                
                const populationStdFloat = parseFloat(populationStd);
                const sampleSize = this.generatedData.length;
                const standardError = populationStdFloat / Math.sqrt(sampleSize);
                const zScore = (sampleMean - hypothesizedMean) / standardError;
                
                // è®¡ç®—på€¼
                let pValue;
                const cumulativeProbability = this.normalCDF(zScore);
                
                switch(testDirection) {
                    case 'two-tailed':
                        pValue = 2 * Math.min(cumulativeProbability, 1 - cumulativeProbability);
                        break;
                    case 'left-tailed':
                        pValue = cumulativeProbability;
                        break;
                    case 'right-tailed':
                        pValue = 1 - cumulativeProbability;
                        break;
                }
                
                // è®¡ç®—ä¸´ç•Œå€¼
                let criticalValue = this.getZScore(1 - significanceLevel/2);
                
                const rejectNull = pValue < significanceLevel;
                
                return {
                    testType: 'Zæ£€éªŒ',
                    sampleMean,
                    hypothesizedMean,
                    populationStd: populationStdFloat,
                    sampleSize,
                    zScore,
                    pValue,
                    criticalValue,
                    significanceLevel,
                    rejectNull,
                    testDirection,
                    resultMessage: rejectNull ? 
                        `åœ¨æ˜¾è‘—æ€§æ°´å¹³ Î± = ${significanceLevel} ä¸‹ï¼Œæ‹’ç»åŸå‡è®¾` : 
                        `åœ¨æ˜¾è‘—æ€§æ°´å¹³ Î± = ${significanceLevel} ä¸‹ï¼Œä¸æ‹’ç»åŸå‡è®¾`
                };
            },
            
            // ç¼ºå¤±çš„Zåˆ†æ•°è·å–æ–¹æ³•
            getZScore(probability) {
                // ä½¿ç”¨åè¯¯å·®å‡½æ•°è®¡ç®—Zåˆ†æ•°
                // ä½¿ç”¨è¿‘ä¼¼å…¬å¼è®¡ç®—é€†æ­£æ€åˆ†å¸ƒ
                if (probability <= 0) return -Infinity;
                if (probability >= 1) return Infinity;
                
                // Box-Mullerå˜æ¢çš„é€†è¿‡ç¨‹è¿‘ä¼¼
                const z = Math.sqrt(-2 * Math.log(1 - probability)) * Math.cos(2 * Math.PI * probability);
                return z;
            },
            
            // æ”¹è¿›çš„Tæ£€éªŒpå€¼è®¡ç®—
            approximateTPValue(tScore, degreesOfFreedom, testDirection) {
                // æ›´ç²¾ç¡®çš„Tåˆ†å¸ƒpå€¼è®¡ç®—
                try {
                    if (degreesOfFreedom > 30) {
                        // å¤§æ ·æœ¬æƒ…å†µä¸‹ç”¨æ­£æ€åˆ†å¸ƒè¿‘ä¼¼
                        const cumulativeProbability = this.normalCDF(tScore);
                        
                        switch(testDirection) {
                            case 'two-tailed':
                                return 2 * Math.min(cumulativeProbability, 1 - cumulativeProbability);
                            case 'left-tailed':
                                return cumulativeProbability;
                            case 'right-tailed':
                                return 1 - cumulativeProbability;
                        }
                    }
                    
                    // ä½¿ç”¨æ›´ç²¾ç¡®çš„è¿‘ä¼¼è®¡ç®—
                    const absT = Math.abs(tScore);
                    
                    // åŸºäºè‡ªç”±åº¦å’Œtç»Ÿè®¡é‡çš„æ›´ç²¾ç¡®è¿‘ä¼¼
                    // è¿™é‡Œä½¿ç”¨æ›´å¹³æ»‘çš„è¿‘ä¼¼å…¬å¼
                    const scaledT = absT / Math.sqrt(degreesOfFreedom / (degreesOfFreedom - 2));
                    let pValue = 1.0 / (1 + Math.pow(scaledT, degreesOfFreedom/2) * 0.5);
                    
                    // è°ƒæ•´på€¼ä½¿å…¶åœ¨åˆç†èŒƒå›´å†…
                    pValue = Math.max(0.0001, Math.min(0.9999, pValue));
                    
                    if (testDirection === 'two-tailed') {
                        pValue *= 2;
                    }
                    
                    return pValue;
                } catch (error) {
                    console.error('è®¡ç®—på€¼æ—¶å‡ºé”™:', error);
                    // å‡ºé”™æ—¶è¿”å›é»˜è®¤å€¼
                    return 0.5;
                }
            },
            
            // æ”¹è¿›çš„Tä¸´ç•Œå€¼è®¡ç®—
            approximateTCriticalValue(degreesOfFreedom, alpha, testDirection) {
                try {
                    // æ›´ç²¾ç¡®çš„ä¸´ç•Œå€¼è®¡ç®—
                    if (degreesOfFreedom > 100) {
                        // ä½¿ç”¨Zä¸´ç•Œå€¼
                        return this.getZScore(1 - alpha/2);
                    }
                    
                    // åŸºäºè‡ªç”±åº¦çš„æ›´ç²¾ç¡®ä¸´ç•Œå€¼è®¡ç®—
                    // ä½¿ç”¨è¿‘ä¼¼å…¬å¼
                    const z = this.getZScore(1 - alpha/2);
                    const correction = (z*z*z + z) / (4 * degreesOfFreedom);
                    const criticalValue = z + correction;
                    
                    // æ ¹æ®æ£€éªŒæ–¹å‘è°ƒæ•´
                    if (testDirection === 'left-tailed') {
                        return -criticalValue;
                    } else if (testDirection === 'right-tailed') {
                        return criticalValue;
                    }
                    
                    return criticalValue; // åŒä¾§æ£€éªŒè¿”å›æ­£ä¸´ç•Œå€¼
                } catch (error) {
                    console.error('è®¡ç®—ä¸´ç•Œå€¼æ—¶å‡ºé”™:', error);
                    // å‡ºé”™æ—¶è¿”å›é»˜è®¤å€¼
                    return 1.96; // é»˜è®¤Zä¸´ç•Œå€¼
                }
            },
            
            // æ”¹è¿›çš„Fæ£€éªŒpå€¼è®¡ç®—
            approximateFPValue(fStatistic, dfBetween, dfWithin) {
                try {
                    if (fStatistic <= 0) return 1.0;
                    
                    // ä½¿ç”¨æ›´ç²¾ç¡®çš„Fåˆ†å¸ƒpå€¼è¿‘ä¼¼
                    // ä½¿ç”¨Satterthwaiteè¿‘ä¼¼
                    const logF = Math.log(fStatistic);
                    const logNumerator = dfBetween / 2 * logF;
                    const logDenominator = Math.log(1 + (dfBetween / dfWithin) * fStatistic) * (dfBetween + dfWithin) / 2;
                    
                    // ç®€åŒ–çš„è¿‘ä¼¼å…¬å¼
                    let pValue = 1.0 / (1 + Math.exp(logNumerator - logDenominator));
                    
                    // è°ƒæ•´på€¼ä½¿å…¶åœ¨åˆç†èŒƒå›´å†…
                    pValue = Math.max(0.0001, Math.min(0.9999, pValue));
                    
                    return pValue;
                } catch (error) {
                    console.error('è®¡ç®—Fæ£€éªŒpå€¼æ—¶å‡ºé”™:', error);
                    // å‡ºé”™æ—¶è¿”å›é»˜è®¤å€¼
                    return 0.5;
                }
            },
            
            // ç¡®ä¿Math.erfå‡½æ•°å¯ç”¨çš„polyfill
            ensureMathErf() {
                if (!Math.erf) {
                    // æ·»åŠ è¯¯å·®å‡½æ•°çš„polyfill
                    Math.erf = function(x) {
                        // ç®€åŒ–çš„è¯¯å·®å‡½æ•°å®ç°
                        const z = Math.abs(x);
                        const t = 1.0 / (1.0 + z / 2.5);
                        const a1 = 0.254829592;
                        const a2 = -0.284496736;
                        const a3 = 1.421413741;
                        const a4 = -1.453152027;
                        const a5 = 1.061405429;
                        const erf = 1 - t * Math.exp(-z * z + a1 * t + a2 * t * t + a3 * t * t * t + a4 * t * t * t * t + a5 * t * t * t * t * t);
                        return x >= 0 ? erf : -erf;
                    };
                }
            },
            
            // è¾…åŠ©ç»Ÿè®¡æ–¹æ³•
            calculateMean(data) {
                // è¾“å…¥éªŒè¯
                if (!Array.isArray(data) || data.length === 0) {
                    console.error('calculateMean: æ— æ•ˆçš„æ•°æ®æ•°ç»„');
                    return 0;
                }
                
                try {
                    // è¿‡æ»¤æ‰éæ•°å€¼å’ŒNaNå€¼
                    const validData = data.filter(value => typeof value === 'number' && !isNaN(value));
                    if (validData.length === 0) {
                        console.error('calculateMean: æ•°ç»„ä¸­æ²¡æœ‰æœ‰æ•ˆæ•°å€¼');
                        return 0;
                    }
                    
                    return validData.reduce((sum, value) => sum + value, 0) / validData.length;
                } catch (error) {
                    console.error('calculateMean: è®¡ç®—å‡å€¼æ—¶å‡ºé”™', error);
                    return 0;
                }
            },
            
            calculateStandardDeviation(data) {
                try {
                    // è¾“å…¥éªŒè¯
                    if (!Array.isArray(data) || data.length <= 1) {
                        console.error('calculateStandardDeviation: æ•°æ®æ•°ç»„é•¿åº¦ä¸è¶³');
                        return 0;
                    }
                    
                    const mean = this.calculateMean(data);
                    
                    // è¿‡æ»¤æ‰éæ•°å€¼å’ŒNaNå€¼
                    const validData = data.filter(value => typeof value === 'number' && !isNaN(value));
                    if (validData.length <= 1) {
                        console.error('calculateStandardDeviation: æœ‰æ•ˆæ•°æ®ç‚¹ä¸è¶³');
                        return 0;
                    }
                    
                    const squaredDifferences = validData.map(value => Math.pow(value - mean, 2));
                    const variance = squaredDifferences.reduce((sum, value) => sum + value, 0) / (validData.length - 1);
                    return Math.sqrt(variance);
                } catch (error) {
                    console.error('calculateStandardDeviation: è®¡ç®—æ ‡å‡†å·®æ—¶å‡ºé”™', error);
                    return 0;
                }
            },
            
            // æ­£æ€åˆ†å¸ƒCDF (ä½¿ç”¨è¿‘ä¼¼è®¡ç®—)
            normalCDF(x) {
                return 0.5 * (1 + Math.erf(x / Math.sqrt(2)));
            },
            
            // æ­£æ€åˆ†å¸ƒPDF
            normalPDF(x) {
                return Math.exp(-0.5 * x * x) / Math.sqrt(2 * Math.PI);
            },
            
            // Tåˆ†å¸ƒPDFè¿‘ä¼¼
            tDistributionPDF(x, df) {
                const gamma = this.approximateGamma((df + 1) / 2) / (Math.sqrt(df * Math.PI) * this.approximateGamma(df / 2));
                return gamma * Math.pow(1 + x * x / df, -(df + 1) / 2);
            },
            
            // è¿‘ä¼¼ä¼½é©¬å‡½æ•°
            approximateGamma(z) {
                // ç®€åŒ–çš„ä¼½é©¬å‡½æ•°è¿‘ä¼¼
                const p = [0.99999999999980993, 676.5203681218851, -1259.1392167224028, 771.32342877765313, -176.61502916214059, 12.507343278686905, -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];
                
                if (z < 0.5) {
                    return Math.PI / (Math.sin(Math.PI * z) * this.approximateGamma(1 - z));
                }
                
                z -= 1;
                let x = p[0];
                for (let i = 1; i < p.length; i++) {
                    x += p[i] / (z + i);
                }
                
                const t = z + p.length - 0.5;
                return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
            }
        };
        
        // åˆå§‹åŒ–åº”ç”¨
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOMåŠ è½½å®Œæˆï¼Œå¼€å§‹åˆå§‹åŒ–åº”ç”¨');
            StatApp.init();
        });
    </script>
</body>
</html>